---
layout:     post
title:      Java多线程
subtitle:   详细分析及多个案例
date:       2017-10-13
author:     赵小恒
header-img: img/home-bg.jpg
catalog: true
tags:
    - java
    - 多线程
---

### 1、概念与原理

#### 1.1操作系统中线程和进程的概念

现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。
线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。 “同时”执行是人的感觉，在线程之间实际上轮换执行。

#### 1.2Java中的线程

在Java中，“线程”指两件不同的事情：
1、java.lang.Thread类的一个实例；
2、线程的执行。
使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义、实例化和启动新线程。
一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。
Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。
一个Java应用总是从main()方法开始运行，mian()方法运行在一个线程内，它被称为主线程。
一旦创建一个新的线程，就产生一个新的调用栈。

### 2、创建与启动

#### 2.1定义线程

- 2.1.1扩展java.lang.Thread类:
- 2.1.2实现java.lang.Runnable接口：

#### 2.2创建实例并启动
```java
/**
 * 此种方式为扩展java.lang.Thread类
 * 
 */
public class Test extends Thread { 
	
	/**
	 * 构造方法初始化属性
	 * @param name
	 */
	public Test(String name){
	
            super(name);
        }
	
	public static void main(String[] args){
		 
		//创建一个线程：
		Test test1 = new Test("线程1");
		test1.start();// 启动一个线程

		Test test2 = new Test("线程2");
		test2.start();// 启动一个线程

	 }
	/**
	 *  run方法是多线程的业务方法
	 */
	public void run() {
		while (true) {
			System.out.println(Thread.currentThread().getName());
		}
	}

}
```
```java
/**
 * 此种方式为实现Runnable接口的多线程
 * 
 */
public class Test implements Runnable {

    private String name;
    /**
    * 构造方法初始化属性
    * @param name
    */
    public Test(String name) {
        this.name = name;
    } 

    public void run() {
    	while (true) {
			System.out.println(name);
		}
    } 
	
    public static void main(String[] args){
		 
	// 创建线程7：
	Test test1 = new Test("线程1--------------");
	Thread t1 = new Thread(test1);
	t1.start();// 启动一个线程

	Test test2 = new Test("线程2+++++++++++++");
	Thread t2 = new Thread(test2);
	t2.start();// 启动一个线程
    }

}	
```

### 3、一些常见问题

（1）线程的名字，一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，
虚拟机总会为线程指定名字，并且主线程的名字总是mian，非主线程的名字不确定。

（2）线程都可以设置名字，也可以获取线程的名字，连主线程也不例外。

（3）获取当前线程的对象的方法是：Thread.currentThread()。

（4）在上面的代码中，只能保证：每个线程都将启动，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按该顺序执行。
     对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。

（5）当线程目标run()方法结束时该线程完成。

（6）一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次。一个可运行的线程或死线程可以被重新启动。

（7）线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。
     众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的。

（8）尽管通常采用队列形式（先进先出的数据存储方式），但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，
   它才能被再次选中。事实上，我们把它称为可运行池而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列而成一个一个队列的事实。

（9）尽管我们无法控制线程调度程序，但可以通过别的方式来影响线程调度。

### 4、线程栈模型

要理解线程调度的原理，以及线程执行过程，必须理解线程栈模型。
线程栈是指某时刻时内存中线程调度的栈信息，当前调用的方法总是位于栈顶。线程栈的内容是随着程序的运行动态变化的，
因此研究线程栈必须选择一个运行的时刻（实际上指代码运行到什么地方)。
下面通过一个示例性的代码说明线程（调用）栈的变化过程。
![](/img/duoxiancheng/zh-xczmx.jpg)
虚拟机线程调用栈示意图:
程序执行到(1)时，栈中只有一个main方法，执行到（2）时，会先把println方法装进来，等打印完成再释放出去，
执行到（3），会把Test的构造函数装进来，构造完成再释放出去，再把method方法装进来，依次类推，执行到（4），
会开辟一个新栈，单独执行run方法，之前的装着main方法的栈依然独立存在运行着，与装着run方法的栈不发生冲突，
程序多出一个分支（增加了一个装着run方法的调用栈），他们并行执行。从这里就可以看出方法调用和线程启动的区别了。


### 5、线程状态的转换

#### 5.1线程状态

线程的状态转换是线程控制的基础。线程状态总的可以分为五大状态。用一个图来描述如下：
![](/img/duoxiancheng/zh-xczt.png)
（1）新状态：线程对象已经创建，还没有在其上调用start()方法。

（2）可运行状态：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，
     线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。
	 
（3）运行状态：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。

（4）等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，
     但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态。
	 
（5）死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。
     线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。

然后点击`Window`->`ESJsonFormat`->`Input JSON Window`调出窗口

#### 5.2阻止线程执行
>对于线程的阻止，考虑一下三个方面，不考虑IO阻塞的情况：
- sleep()；
- yield()；
- join()。

（5.2.1）sleep()：
Thread.sleep(longmillis)和Thread.sleep(long millis, int nanos)静态方法强制当前正在执行的线程休眠（暂停执行），
以“减慢线程”。当线程睡眠时，它入睡在某个地方，在苏醒之前不会返回到可运行状态。当睡眠时间到期，则返回到可运行状态。
```java
public class Test extends Thread {

	public void run(){  
	       for(int i=0;i<100;i++){  
	           if ((i)%10==0) {  
	              System.out.println("--------"+i);  
	           }  
	           System.out.print(i);  
	           try {  
	              Thread.sleep(1000);  
	              System.out.print("    线程睡眠1秒！\n");  
	           } catch (InterruptedException e) {  
	              e.printStackTrace();  
	           }  
	       }  
	    }  
	   
	    public static void main(String[] args) {  
	       new Test().start();  
	    }  

}
```
>注意：
1、线程睡眠是帮助所有线程获得运行机会的最好方法。
2、线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态。sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行。
3、sleep()是静态方法，只能控制当前正在运行的线程。

（5.2.2）yield()：
线程的让步是通过Thread.yield()来实现的。yield()方法的作用是：暂停当前正在执行的线程对象，并执行其他线程。
要理解yield()，必须了解线程的优先级的概念。线程总是存在优先级，优先级范围在1~10之间。JVM线程调度程序是基于优先级的抢先调度机制。
在大多数情况下，当前运行的线程优先级将大于或等于线程池中任何线程的优先级。但这仅仅是大多数情况。
>注意：当设计多线程应用程序的时候，一定不要依赖于线程的优先级。因为线程调度优先级操作是没有保障的，
       只能把线程优先级作用作为一种提高程序效率的方法，但是要保证程序不依赖这种操作。
       当线程池中线程都具有相同的优先级，调度程序的JVM实现自由选择它喜欢的线程。这时候调度程序的操作有两种可能：
	   一是选择一个线程运行，直到它阻塞或者运行完成为止。二是时间分片，为池内的每个线程提供均等的运行机会。

设置线程的优先级：线程默认的优先级是5。可以通过setPriority(int newPriority)更改线程的优先级.线程优先级为1~10之间的正整数，
JVM从不会改变一个线程的优先级。然而，1~10之间的值是没有保证的。一些JVM可能不能识别10个不同的值，而将这些优先级进行每两个或多个合并，
变成少于10个的优先级，则两个或多个优先级的线程可能被映射为一个优先级。
```java
Thread t = new MyThread();  
t.setPriority(8);  
t.start();
```
Thread类中有三个常量，定义线程优先级范围：
```java
static intMAX_PRIORITY：线程可以具有的最高优先级。  
static intMIN_PRIORITY：线程可以具有的最低优先级。  
static intNORM_PRIORITY：分配给线程的默认优先级。 
```
yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。
但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。
>注意：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。

（5.2.3）join()：  
```java
public static void main(String[] args){
    
    System.out.println("main start");
    Thread t1 = new Thread(new Worker("thread-1"));
    t1.start();
    t1.join();
    System.out.println("main end");
}
``` 
在上面的例子中，main线程要等到t1线程运行结束后，才会输出“main end”。如果不加t1.join(),main线程和t1线程是并行的。而加上t1.join(),程序就变成是顺序执行了。
另外，join()方法还有带超时限制的重载版本。例如t.join(5000);则让线程等待5000毫秒，如果超过这个时间，则停止等待，变为可运行状态。

>小结:到目前位置，介绍了线程离开运行状态的3种方法：
(1)、调用Thread.sleep()：使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）。
(2)、调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。
(3)、调用join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。
除了以上三种方式外，还有下面几种特殊情况可能使线程离开运行状态：
(1)、线程的run()方法完成。
(2)、在对象上调用wait()方法（不是在线程上调用）。
(3)、线程不能在对象上获得锁定，它正试图运行该对象的方法代码。
(4)、线程调度程序可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由。 

### 6、线程的同步与锁

#### 6.1同步问题提出
>线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏。
例如：两个线程ThreadA、ThreadB都操作同一个对象Foo对象，并修改Foo对象上的数据。

```java
public class Foo {  
    private int x = 100;  
    public int getX() {  
        return x;  
    }  
    public int fix(int y) {  
        x = x - y;  
        return x;  
    }  
}

public class FooRunnable implements Runnable {  
    private Foo foo =new Foo();  
   
    public static void main(String[] args) {  
       FooRunnable r = new FooRunnable();  
        Thread ta = new Thread(r,"Thread-A");  
        Thread tb = new Thread(r,"Thread-B");  
        ta.start();  
        tb.start();  
    }  
   
    @Override  
    public void run() {  
       for (int i = 0; i < 3; i++) {  
            this.fix(30);  
            try {  
                Thread.sleep(1);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
            System.out.println(Thread.currentThread().getName()+ " :当前foo对象的x值= " + foo.getX());  
        }  
    }  
   
    public int fix(int y) {  
       return foo.fix(y);  
    }  
}
```
>执行结果:

```java
Thread-A :当前foo对象的x值= 10
Thread-A :当前foo对象的x值= -20
Thread-B :当前foo对象的x值= -20
Thread-B :当前foo对象的x值= -50
Thread-B :当前foo对象的x值= -800
```

>从结果发现，这样的输出值明显是不合理的，原因是两个线程不加控制的访问Foo对象并修改其数据所致。如果要保持结果的合理性，只需要达到一个目的，
就是将对Foo的访问加以限制，每次只能有一个线程在访问。这样就能保证Foo对象中数据的合理性了。
在具体的Java代码中需要完成以下两个操作：
把竞争访问的资源类Foo变量x标识为private；
同步修改变量的代码，使用synchronized关键字同步方法或代码。

#### 6.2同步和锁定
>锁的原理：
        Java中每个对象都有一个内置锁。java内置锁是一个互斥锁。
        当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。
		获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。
        当程序运行到synchronized同步方法或代码块时才该对象锁才起作用。
        一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。
		这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。
        释放锁是指持锁线程退出了synchronized同步方法或代码块。

        关于锁和同步，有一下几个要点：

        1）只能同步方法，而不能同步变量和类；

        2）每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？

        3）不必同步类中所有的方法，类可以同时拥有同步和非同步方法。

        4）如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，
	       那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：如果一
	       个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。

        5）如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。

        6）线程睡眠时，它所持的任何锁都不会释放。

        7）线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，
		   则获取了两个对象的同步锁。

        8）同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，
		   还可以同步方法中一部分代码块。

        9）在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。例如：
		
```java
    public int fix(int y) {  
		
        synchronized (this) {  
            x = x - y;  
        }  
        return x;  
    }  
```		
当然，同步方法也可以改写为非同步方法，但功能完全一样的，例如：
```java
    public synchronized int getX() {  
	
        return x++;  
    }
```
与
```java
    public int getX() {  
	
        synchronized (this) {  
            return x;  
        }  
    }  
```
效果是完全一样的。

#### 6.3静态方法同步
要同步静态方法，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class)。
例如：
```java
    public static synchronized int getName(String name){  
       
    }  
```   
等价于
```java
    public static int getName(String name){  
        synchronized(Test.class){  
            
        }  
    } 
```
>注意：在使用synchronized块来同步方法时，非静态方法可以通过this来同步，而静态方法必须使用class对象来同步，
但是非静态方法也可以通过使用class来同步静态方法。但是静态方法中不能使用this来同步非静态方法。这点在使用synchronized块需要注意。

#### 6.4如果线程不能获得锁会怎么样
>如果线程试图进入同步方法，而其锁已经被占用，则线程在该对象上被阻塞。实质上，线程进入该对象的一种池中，必须在那里等待，直到其锁被释放，该线程再次变为可运行或运行为止。
 考虑阻塞时，一定要注意哪个对象正被用于锁定：

    1、调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，
	   则每个线程有自己的对象的锁，线程间彼此互不干预。

    2、调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。

    3、静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，
	   非静态方法锁定在该类的对象上。

    4、对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。
	   在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞。
		   
#### 6.5何时需要同步
>在多个线程同时访问互斥（可交换）数据时，应该同步以保护数据，确保两个线程不会同时修改更改它。如果是共享数据，则不需要同步。
对于非静态字段中可更改的数据，通常使用非静态方法访问。
对于静态字段中可更改的数据，通常使用静态方法访问。

#### 6.6线程安全类
>当一个类已经很好的同步以保护它的数据时，这个类就称为“线程安全的”。
即使是线程安全类，也应该特别小心，因为操作的线程之间仍然不一定安全。

举个形象的例子，比如一个集合是线程安全的，有两个线程在操作同一个集合对象，当第一个线程查询集合非空后，
删除集合中所有元素的时候。第二个线程也来执行与第一个线程相同的操作，也许在第一个线程查询后，
第二个线程也查询出集合非空，但是当第一个执行清除后，第二个再执行删除显然是不对的，因为此时集合已经为空了。
解决方法为在操作的方法上添加同步，这样，当一个线程访问其中一个同步方法时，其他线程只有等待。

```java
public class NameList {

    //创造线程安全的集合类
    private List nameList = Collections.synchronizedList(new LinkedList());  
	   
    public void add(String name) {  
        nameList.add(name);  
    }  
   
    public String removeFirst() {  
       if (nameList.size()>0) {  
    	   try {
    		   	//让线程睡眠1秒，创造两个线程都读取到数据的场景
			    Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
    	   return (String) nameList.remove(0); 
       } else {  
           return null;  
       }  
    }    
}
```
```java
public class TestNameList {
	
    public static void main(String[] args) {  
        final NameList nl =new NameList();  
         nl.add("苏东坡");  
         class NameDropper extends Thread{  
           @Override  
           public void run() {
              String name = nl.removeFirst();  
                System.out.println(name);  
           }          
         }  
         Thread t1=new NameDropper();  
         Thread t2=new NameDropper();  
         t1.start(); 
         t2.start();  
    }  
}
```
运行结果：
```java
苏东坡
Exception in thread "Thread-1" java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
	at java.util.LinkedList.checkElementIndex(LinkedList.java:553)
	at java.util.LinkedList.remove(LinkedList.java:523)
	at java.util.Collections$SynchronizedList.remove(Collections.java:1888)
	at NameList.removeFirst(NameList.java:20)
	at TestNameList$1NameDropper.run(TestNameList.java:10)
```
结果是报错了，虽然集合对象
```java
    private List nameList =Collections.synchronizedList(new LinkedList());  
```
是同步的，但是程序还不是线程安全的。出现这种事件的原因是，上例中一个线程操作列表过程中无法阻止另外一个线程对列表的其他操作。
解决上面问题的办法是，在操作集合对象nameList上面做一个同步。改写后的代码如下：
```java
public class NameList { 
 
    private List nameList = Collections.synchronizedList(new LinkedList());  
   
    public synchronized void add(String name) {  
        nameList.add(name);  
    }  
   
    public synchronized String removeFirst() {  
    	if (nameList.size()>0) {  
     	   try {
 			    Thread.sleep(1000);
 			} catch (InterruptedException e) {
 				e.printStackTrace();
 			}
     	   return (String) nameList.remove(0); 
        } else {  
            return null;  
        }   
       
    }    
}
```
### 7、线程死锁
>死锁对Java程序来说，是很复杂的，也很难发现问题。当一个线程被阻塞，另一个线程在等待阻塞的线程时就发生死锁。		
```java
class Lock1 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock1 running");
            while(true){
                synchronized(DeadLock.obj1){
                    System.out.println("Lock1 lock obj1");
                    Thread.sleep(3000);//获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2
                    synchronized(DeadLock.obj2){
                        System.out.println("Lock1 lock obj2");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```
```java
class Lock2 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock2 running");
            while(true){
                synchronized(DeadLock.obj2){
                    System.out.println("Lock2 lock obj2");
                    Thread.sleep(3000);
                    synchronized(DeadLock.obj1){
                        System.out.println("Lock2 lock obj1");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```
```java
public class DeadLock {
    public static String obj1 = "obj1";
    public static String obj2 = "obj2";
    public static void main(String[] args){
        Thread a = new Thread(new Lock1());
        Thread b = new Thread(new Lock2());
        a.start();
        b.start();
    }    
}
```
运行结果：
```java
Lock1 running
Lock2 running
Lock1 lock obj1
Lock2 lock obj2
```
线程a锁住变量obj1，线程b锁住变量obj2，线程a就没办法锁住obj2，线程b也没办法锁住obj1，这时就陷入了死锁。

### 8.线程同步小结

```ruby
1、线程同步的目的是为了保护多个线程访问同一个资源时对资源的破坏。

2、线程同步方法是通过锁来实现，每个对象都有且仅有一个锁，这个锁与一个特定的对象关联，
线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。

3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。
静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，
会获取这两个对象锁。

4、对于同步，要时刻清醒在哪个对象上同步，这是关键。

5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，
对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。

6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。

7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。

```
### 9.线程的交互
#### 9.1线程交互的基础知识		
>线程交互知识点需要从java.lang.Object的类的三个方法来学习：

```
(1)void notify()——唤醒在此对象监视器上等待的单个线程。  
(2)void notifyAll()——唤醒在此对象监视器上等待的所有线程。  
(3)void wait()——导致当前的线程等待，直到其他线程调用此对象的 notify()方法或 notifyAll()方法。
```

>当然，wait()还有另外两个重载方法：


**(1)void wait(long timeout)——导致当前的线程等待，直到其他线程调用此对象的 notify()方法
或 notifyAll()方法，或者超过指定的时间量。** 
**(2)void wait(long timeout, int nanos)——导致当前的线程等待，直到其他线程调用此对象的 
notify()方法或 notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。** 
		
```
public class ThreadA {  
    public static void main(String[] args) {  
       ThreadB b=new ThreadB();  
       //启动计算线程  
       b.start();  
       //线程A拥有b对象上的锁。线程为了调用wait()或notify()方法，该线程必须是那个对象锁的拥有者  
       synchronized (b) {  
           try {  
              System.out.println("等待对象b完成计算......");  
              b.wait();  
           } catch (Exception e) {  
              e.printStackTrace();  
           }  
           System.out.println("b对象计算的总和是：" + b.total);  
       }  
    }  
}

public class ThreadB extends Thread {  
    int total;  
    public void run(){  
       synchronized (this) {  
    	     
           for (int i=0;i<101;i++){  
              total+=i;  
           }  
           //（完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程A被唤醒  
           notify();
       }  
    }  
}
```

执行结果：

```
等待对象b完成计算......
b对象计算的总和是：5050
```

**千万注意：
当在对象上调用wait()方法时，执行该代码的线程立即放弃它在对象上的锁。
然而调用notify()时，并不意味着这时线程会放弃其锁。如果线程仍然在完成同步代码，
则线程在移出之前不会放弃锁。因此，只要调用notify()并不意味着这时该锁变得可用。**

[参考：wait()与notify()的详解](http://blog.csdn.net/lingzhm/article/details/44940823)  
[参考：synchronized和wait()、notify()的关系](http://blog.163.com/sunflower123_happy/blog/static/17327442120112264383864/)

#### 9.2多个线程的notifyAll()

>在多数情况下，最好通知等待某个对象的所有线程。如果这样做，
可以在对象上使用notifyAll()让所有在此对象上等待的线程冲出等待区，返回到可运行状态。  
举个例子：
  
```
/** 
 * 生产者，生成字符 
 */ 
class Producer implements Runnable {  
    SyncStack theStack;  
  
    public Producer(SyncStack s) {  
        theStack = s;  
    }  
  
    public void run() {  
        char c;  
        for (int i = 0; i < 20; i++) {  
            c = (char) (Math.random() * 26 + 'A');// 生成A-Z  
            theStack.push(c);  
            try {  
                Thread.sleep((int) (Math.random() * 1000));// 随机休眠0-1000毫秒  
            } catch (InterruptedException e) {  
            }  
        }  
    }  
}

/** 
 * 消费者，获取字符并打印 
 */  
class Consumer implements Runnable {  
    SyncStack theStack;  
  
    public Consumer(SyncStack s) {  
        theStack = s;  
    }  
  
    public void run() {  
        char c;  
        for (;;) {  
            c = theStack.pop();  
            try {  
                Thread.sleep((int) (Math.random() * 1000));  
            } catch (InterruptedException e) {  
            }  
        }  
    }  
}  

/**
 * 生产消费行为
 */
class SyncStack {  
    private int index = 0;  
    private char[] buffer = new char[6];  
  
    public synchronized void push(char c) {  
        //栈满，该方法将处于wait状态  
        while (index == buffer.length) {  
            try {  
                System.out.println(Thread.currentThread().getName()  
                        + " wait...");  
                wait();  
                System.out.println(Thread.currentThread().getName()  
                        + " isAlive!");  
            } catch (InterruptedException e) {  
                System.out.println(Thread.currentThread().getName()  
                        + " InterruptedException");  
            }  
        }  
  
        buffer[index] = c;  
        index++;  
        System.out.println(Thread.currentThread().getName() + " 生成了：" + c);  
        notifyAll();
		//notify();
    }  
  
    public synchronized char pop() {  
        //栈空，该方法将处于wait状态  
        while (index == 0) {  
            try {  
                System.out.println(Thread.currentThread().getName()  
                        + " wait...");  
                wait();  
                System.out.println(Thread.currentThread().getName()  
                        + " isAlive!");  
            } catch (InterruptedException e) {  
                System.out.println(Thread.currentThread().getName()  
                        + " InterruptedException");  
            }  
        }  
  
        index--;  
        char c = buffer[index];  
        System.out.println(Thread.currentThread().getName() + " 消费了: " + c);  
        notifyAll()
		//notify();
        return c;  
    }  
}  

/**
 * 测试方法
 */
public class SyncTest {  
    public static void main(String arguments[]) throws Exception {  
        SyncStack stack = new SyncStack();  
        Thread producerThread1 = new Thread(new Producer(stack), "producerThread1");  
        Thread producerThread2 = new Thread(new Producer(stack), "producerThread2");  
        Thread consumerThread1 = new Thread(new Consumer(stack), "consumerThread1");  
        Thread consumerThread2 = new Thread(new Consumer(stack), "consumerThread2");  
  
        consumerThread1.start();  
        consumerThread2.start();  
  
        // 暂停3秒，造成饥饿状态  
        Thread.sleep(3000);  
  
        producerThread1.start();  
        producerThread2.start();  
    }  
}
```  
输出结果  
```
consumerThread1 wait...
consumerThread2 wait...//两个消费者都进入wait堆栈  
producerThread1 生成了：W//consumerThread1 ,consumerThread2激活
consumerThread2 isAlive!
consumerThread2 消费了: W
consumerThread1 isAlive!
consumerThread1 wait...
producerThread2 生成了：F
consumerThread1 isAlive!
consumerThread1 消费了: F
producerThread2 生成了：H
consumerThread1 消费了: H
producerThread1 生成了：K
consumerThread2 消费了: K
consumerThread2 wait...
consumerThread1 wait...
producerThread2 生成了：P
consumerThread1 isAlive!
consumerThread1 消费了: P
consumerThread2 isAlive!
consumerThread2 wait...
producerThread1 生成了：I
(...)
```  
[参考：notify与notifyAll的不同](http://blog.csdn.net/tayanxunhua/article/details/20998809) 

#### 9.3线程的调度	
##### 9.3.1 休眠	

>Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。
这里要明确的一点，不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。
线程休眠的目的是使线程让出CPU的最简单的做法之一，线程休眠时候，会将CPU资源交给其他线程，以便能轮换执行，
当休眠一定时间后，线程会苏醒，进入准备状态等待执行。线程休眠的方法是Thread.sleep(long millis)
和Thread.sleep(long millis, int nanos)，均为静态方法，
那调用sleep休眠的哪个线程呢？简单说，哪个线程调用sleep，就休眠哪个线程。

**注意：wait()方法与notify()必须要与synchronized(resource)一起使用。也就是wait与notify针对已经获取了resource锁的线程进行操作，
从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。从功能上来说wait()线程在获取对象锁后，主动释放CPU控制权，
主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。
相应的notify()就是对对象锁的释放操作。因此，wait和notify方法均可释放对象的锁，但wait同时释放CPU控制权（即它后面的代码停止执行），线程进入阻塞状态，
而notify方法不立刻释放CPU控制权，而是在相应的synchronized(){}语句块执行结束释放锁，JVM会在等待resoure的线程中选取一线程，
赋予其对象锁，唤醒线程，使其继续执行（同时释放cpu控制权）。  
Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，
主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制，而在同步块中的Thread.sleep()方法并不释放锁，仅释放CPU控制权。**

```
public class TestSleep {  
    public static void main(String[] args) {  
       Thread t1=new MyThread1();  
       Thread t2=new Thread(new MyRunnable());  
       t1.start();  
       t2.start();  
    }  
}

class MyThread1 extends Thread{  
    @Override  
    public void run() {  
       for(int i=0;i<3;i++){  
           System.out.println("线程1第"+i+"次执行！");  
           try {  
              Thread.sleep(50);  
           } catch (InterruptedException e) {  
              e.printStackTrace();  
           }  
       }  
    }    
} 

class MyRunnable implements Runnable{  
    @Override  
    public void run() {       
       for(int i=0;i<3;i++){  
           System.out.println("线程2第"+i+"次执行！");  
           try {  
              Thread.sleep(50);  
           } catch (InterruptedException e) {  
              e.printStackTrace();  
           }  
       }  
    }    
}  
```  
`执行结果：`  
```
线程1第0次执行！  
线程2第0次执行！  
线程2第1次执行！  
线程1第1次执行！  
线程2第2次执行！  
线程1第2次执行！
```

从上面的结果输出可以看出，无法精准保证线程执行次序。

#### 9.3.2 优先级

>与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。
线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。
在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。

```
public class TestPriority {  
    public static void main(String[] args) {  
       Thread t1=new MyThread1();  
       Thread t2=new Thread(new MyRunnable());  
       t1.setPriority(10);  
       t2.setPriority(1);  
       t1.start();  
       t2.start();  
    }  
} 

class MyThread1 extends Thread{  
    @Override  
    public void run() {  
       for(int i=0;i<10;i++){  
           System.out.println("线程1第"+i+"次执行！");  
           try {  
              Thread.sleep(100);  
           } catch (InterruptedException e) {  
              e.printStackTrace();  
           }  
       }  
    }    
} 

class MyRunnable implements Runnable{  
    @Override  
    public void run() {       
       for(int i=0;i<10;i++){  
           System.out.println("线程2第"+i+"次执行！");  
           try {  
              Thread.sleep(100);  
           } catch (InterruptedException e) {  
              e.printStackTrace();  
           }  
       }  
    }    
}
```  
`执行结果：`  
```
线程1第0次执行！  
线程1第1次执行！  
线程1第2次执行！  
线程2第0次执行！  
线程1第3次执行！  
线程2第1次执行！  
线程1第4次执行！  
线程2第2次执行！  
线程1第5次执行！  
线程2第3次执行！  
线程1第6次执行！  
线程2第4次执行！  
线程1第7次执行！  
线程2第5次执行！  
线程1第8次执行！  
线程2第6次执行！  
线程1第9次执行！  
线程2第7次执行！  
线程2第8次执行！  
线程2第9次执行！
```	

#### 9.3.3 让步	

>线程的让步含义就是使当前运行着的线程让出CPU资源，使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。
cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，
并不是说一定会执行其他线程而该线程在下一次中不会执行到了。用了yield方法后，该线程就会把CPU时间让掉，
让其他或者自己的线程执行（也就是谁先抢到谁执行）。
线程的让步使用Thread.yield()方法，yield()为静态方法，功能是暂停当前正在执行的线程对象，并执行其他线程。

```
public class Test {  
    public static void main(String[] args) {  
       Thread t1=new MyThread1();  
       Thread t2=new Thread(new MyRunnable());  
       t1.start();  
       t2.start();  
    }  
}

class MyThread1 extends Thread{  
    @Override  
    public void run() {  
       for(int i=0;i<10;i++){  
           System.out.println("线程1第"+i+"次执行！");          
       }  
    }    
}

class MyRunnable implements Runnable{  
    @Override  
    public void run() {       
       for(int i=0;i<10;i++){  
           System.out.println("线程2第"+i+"次执行！");  
           Thread.yield();  
       }  
    }    
}
```  
`执行结果：`  
```
线程2第0次执行！  
线程1第0次执行！  
线程1第1次执行！  
线程1第2次执行！  
线程1第3次执行！  
线程1第4次执行！  
线程1第5次执行！  
线程1第6次执行！  
线程1第7次执行！  
线程1第8次执行！  
线程1第9次执行！  
线程2第1次执行！  
线程2第2次执行！  
线程2第3次执行！  
线程2第4次执行！  
线程2第5次执行！  
线程2第6次执行！  
线程2第7次执行！  
线程2第8次执行！  
线程2第9次执行！
```

#### 9.3.4 合并

>线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程
执行完毕才能执行,此时可以使用join方法。join为非静态方法，定义如下：  

```
void join()——等待该线程终止。     
void join(long millis)——等待该线程终止的时间最长为 millis毫秒。     
void join(long millis,int nanos)——等待该线程终止的时间最长为 millis毫秒 + nanos 纳秒。
```  
```
public class Test {  
    public static void main(String[] args) {  
       Thread t1=new MyThread1();       
       t1.start();  
       for (int i = 0; i < 20; i++) {  
           System.out.println("主线程第" + i +"次执行！");  
           if (i>2) {  
              try {  
                  ///t1线程合并到主线程中，主线程停止执行过程，转而执行t1线程，直到t1执行完毕后继续。  
                  t1.join();  
              } catch (InterruptedException e) {  
                  e.printStackTrace();  
              }  
           }  
       }  
    }  
}

class MyThread1 extends Thread{  
    @Override  
    public void run() {  
       for(int i=0;i<10;i++){  
           System.out.println("线程1第"+i+"次执行！");          
       }  
    }    
} 
```  

`执行结果：`  

```
主线程第0次执行！  
主线程第1次执行！  
主线程第2次执行！  
主线程第3次执行！  
线程1第0次执行！  
线程1第1次执行！  
线程1第2次执行！  
线程1第3次执行！  
线程1第4次执行！  
线程1第5次执行！  
线程1第6次执行！  
线程1第7次执行！  
线程1第8次执行！  
线程1第9次执行！  
主线程第4次执行！  
主线程第5次执行！  
主线程第6次执行！  
主线程第7次执行！  
主线程第8次执行！  
主线程第9次执行！  
主线程第10次执行！  
主线程第11次执行！  
主线程第12次执行！  
主线程第13次执行！  
主线程第14次执行！  
主线程第15次执行！  
主线程第16次执行！  
主线程第17次执行！  
主线程第18次执行！  
主线程第19次执行！
```

#### 9.3.5 守护线程

>守护线程与普通线程写法上基本么啥区别，调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。
守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。
还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。  
setDaemon方法的详细说明：

```
public final void setDaemon(boolean on)
将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java虚拟机退出。
```  
`该方法必须在启动线程前调用。该方法首先调用该线程的 checkAccess方法，且不带任何参数。
这可能抛出 SecurityException（在当前线程中）。参数：on - 如果为true，则将该线程标记为守护线程。
抛出：IllegalThreadStateException- 如果该线程处于活动状态。SecurityException- 如果当前线程无法修改该线程。`

```
public class Test {  
    public static void main(String[] args) {  
       Thread t1=new MyCommon();  
       Thread t2=new Thread(new MyDaemon());  
       t2.setDaemon(true);//设置为守护线程  
       t2.start();  
       t1.start();        
    }  
}

class MyCommon extends Thread{  
    @Override  
    public void run() {  
       for(int i=0;i<5;i++){  
           System.out.println("线程1第"+i+"次执行！");  
           try {  
              Thread.sleep(7);  
           } catch (InterruptedException e) {  
              e.printStackTrace();  
           }  
       }  
    }    
}

class MyDaemon implements Runnable{  
    @Override  
    public void run() {  
       for (long i = 0; i < 9999999L; i++) {  
           System.out.println("后台线程第" + i +"次执行！");  
           try {  
              Thread.sleep(7);  
           } catch (InterruptedException e) {  
              e.printStackTrace();  
           }  
       }  
    }    
}
```  
`执行结果：`  
```
线程1第0次执行！  
后台线程第0次执行！  
后台线程第1次执行！  
线程1第1次执行！  
后台线程第2次执行！  
线程1第2次执行！  
后台线程第3次执行！  
线程1第3次执行！  
后台线程第4次执行！  
线程1第4次执行！  
后台线程第5次执行！  
后台线程第6次执行！  
后台线程第7次执行！  
后台线程第8次执行！  
后台线程第9次执行！  
后台线程第10次执行！
```  
从上面的执行结果可以看出：
前台线程是保证执行完毕的，后台线程还没有执行完毕就退出了。
实际上：JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，
因此，在使用守护线程时一定要注意这个问题。

#### 9.4 线程的同步
##### 9.4.1 同步方法

>线程的同步是保证多线程安全访问竞争资源的一种手段。
对于同步，在具体的Java代码中需要完成一下两个操作：
把竞争访问的资源标识为private；
同步哪些修改变量的代码，使用synchronized关键字同步方法或代码。
当然这不是唯一控制并发安全的途径。synchronized只能标记非抽象的方法，不能标识成员变量。  
为了演示同步方法的使用，构建了一个信用卡账户，起初信用额为100w，然后模拟透支、存款等多个操作。
显然银行账户User对象是个竞争资源，而多个并发操作的是账户方法oper(int x)，当然应该在此方法上加上同步，
并将账户的余额设为私有变量，禁止直接访问。

`注意：线程的运行状态主要有runnable、running、waiting、timed_waiting、blocked等，主要有2类API，可以控制线程的运行状态。
第一类是调度类，不涉及object monitor和synchronized方法，这类API包括yield()、sleep()、join()等，这类API不涉及同步方法，
是直接控制线程的运行状态，都是Thread类定义的方法  
第二类是同步类，
涉及到object monitor和synchronized方法，这类API包括wait()、notify()、notifyAll()`

[参考：调度与同步的区别](http://kyfxbl.iteye.com/blog/1832689)

```
public class Test {
        public static void main(String[] args) {
                User u = new User("张三", 100);
                MyThread t1 = new MyThread("线程A", u, 20);
                MyThread t2 = new MyThread("线程B", u, -60);
                MyThread t3 = new MyThread("线程C", u, -80);
                MyThread t4 = new MyThread("线程D", u, -30);
                MyThread t5 = new MyThread("线程E", u, 32);
                MyThread t6 = new MyThread("线程F", u, 21);

                t1.start(); 
                t2.start(); 
                t3.start(); 
                t4.start(); 
                t5.start(); 
                t6.start(); 
        } 
}

class MyThread extends Thread { 
        private User u;
        private int y = 0;

        MyThread(String name, User u, int y) {
                super(name);
                this.u = u;
                this.y = y;
        } 

        public void run() {
                u.oper(y); 
        } 
} 

class User { 
        private String code;
        private int cash;

        User(String code, int cash) {
                this.code = code;
                this.cash = cash;
        } 

        public String getCode() {
                return code;
        } 

        public void setCode(String code) {
                this.code = code;
        } 

        /** 
         * 业务方法
         * @param x 添加x万元
         */ 
        public synchronized void oper(int x) {
                try {
                        Thread.sleep(10L); 
                        this.cash += x;
                        System.out.println(Thread.currentThread().getName() + "运行结束，增加“"+ x +"”，当前用户账户余额为：" + cash);
                        Thread.sleep(10L); 
                } catch (InterruptedException e) {
                        e.printStackTrace(); 
                } 
        } 

        @Override 
        public String toString() {
                return"User{" +
                                "code='" + code + '\'' +
                                ", cash=" + cash +
                                '}'; 
        } 
}
```  

`输出结果：`

```
线程A运行结束，增加“20”，当前用户账户余额为：120
线程F运行结束，增加“21”，当前用户账户余额为：141
线程E运行结束，增加“32”，当前用户账户余额为：173
线程C运行结束，增加“-80”，当前用户账户余额为：93
线程B运行结束，增加“-60”，当前用户账户余额为：33
线程D运行结束，增加“-30”，当前用户账户余额为：3
```

`不同步的情况，也就是去掉oper(int x)方法的synchronized修饰符，然后运行程序，结果如下：`

```
线程A运行结束，增加“20”，当前用户账户余额为：61
线程D运行结束，增加“-30”，当前用户账户余额为：63
线程B运行结束，增加“-60”，当前用户账户余额为：3
线程F运行结束，增加“21”，当前用户账户余额为：61
线程E运行结束，增加“32”，当前用户账户余额为：93
线程C运行结束，增加“-80”，当前用户账户余额为：61
```

很显然，上面的结果是错误的，导致错误的原因是多个线程并发访问了竞争资源u，并对u的属性做了改动。


`
注意：通过前文可知，线程退出同步方法时将释放掉方法所属对象的锁，但还应该注意的是，
同步方法中还可以使用特定的方法对线程进行调度。这些方法来自于java.lang.Object类,如下：
`

```
void notify():唤醒在此对象监视器上等待的单个线程。    
void notifyAll():唤醒在此对象监视器上等待的所有线程。    
void wait():导致当前的线程等待，直到其他线程调用此对象的 notify()方法或 notifyAll()方法。    
void wait(long timeout):导致当前的线程等待，直到其他线程调用此对象的 notify()方法或 notifyAll()方法，或者超过指定的时间量。    
void wait(long timeout,int nanos):导致当前的线程等待，直到其他线程调用此对象的 notify()方法或 notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。
```

##### 9.4.2 同步块

>对于同步，除了同步方法外，还可以使用同步代码块，有时候同步代码块会带来比同步方法更好的效果。
追其同步的根本的目的，是控制竞争资源的正确的访问，因此只要在访问竞争资源的时候保证同一时刻只能一个线程访问即可，
因此Java引入了同步代码快的策略，以提高性能。在上个例子的基础上，
对oper方法做了改动，由同步方法改为同步代码块模式，程序的执行逻辑并没有问题。

```
public class Test {
        public static void main(String[] args) {
                User u = new User("张三", 100);
                MyThread t1 = new MyThread("线程A", u, 20);
                MyThread t2 = new MyThread("线程B", u, -60);
                MyThread t3 = new MyThread("线程C", u, -80);
                MyThread t4 = new MyThread("线程D", u, -30);
                MyThread t5 = new MyThread("线程E", u, 32);
                MyThread t6 = new MyThread("线程F", u, 21);

                t1.start(); 
                t2.start(); 
                t3.start(); 
                t4.start(); 
                t5.start(); 
                t6.start(); 
        } 
} 

class MyThread extends Thread { 
        private User u;
        private int y = 0;

        MyThread(String name, User u, int y) {
                super(name);
                this.u = u;
                this.y = y;
        } 

        public void run() {
                u.oper(y); 
        } 
} 

class User { 
        private String code;
        private int cash;

        User(String code, int cash) {
                this.code = code;
                this.cash = cash;
        } 

        public String getCode() {
                return code;
        } 

        public void setCode(String code) {
                this.code = code;
        } 

        /** 
         * 业务方法
         * 
         * @param x 添加x万元
         */ 
        public void oper(int x) {
                try {
                        Thread.sleep(10L); 
                        synchronized (this) {
                                this.cash += x;
                                System.out.println(Thread.currentThread().getName() +"运行结束，增加“" + x +"”，当前用户账户余额为：" + cash);
                        } 
                        Thread.sleep(10L); 
                } catch (InterruptedException e) {
                        e.printStackTrace(); 
                } 
        } 

        @Override 
        public String toString() {
                return"User{" +
                                "code='" + code + '\'' +
                                ", cash=" + cash +
                                '}'; 
        } 
}
```

`运行结果：`

```
线程E运行结束，增加“32”，当前用户账户余额为：132
线程B运行结束，增加“-60”，当前用户账户余额为：72
线程D运行结束，增加“-30”，当前用户账户余额为：42
线程F运行结束，增加“21”，当前用户账户余额为：63
线程C运行结束，增加“-80”，当前用户账户余额为：-17
线程A运行结束，增加“20”，当前用户账户余额为：3
```

`注意：在使用synchronized关键字时候，应该尽可能避免在synchronized方法或synchronized块中使用sleep或者yield方法，因为
synchronized程序块占有着对象锁，你休息那么其他的线程只能一边等着你醒来执行完了才能执行。不但严重影响效率，也不合逻辑。
同样，在同步程序块内调用yeild方法让出CPU资源也没有意义，因为你占用着锁，其他互斥线程还是无法访问同步程序块。
当然与同步程序块无关的线程可以获得更多的执行时间。`

#### 9.5 并发协作
##### 9.5.1 生产者消费者模型

**所谓并发协作就是多个线程一起协同工作，是对上面提到的调度与同步概念的一个实际应用。**

>对于多线程程序来说，不管任何编程语言，生产者和消费者模型都是最经典的。就像学习每一门编程语言一样，
Hello World！都是最经典的例子。实际上，准确说应该是“生产者-消费者-仓储”模型，离开了仓储，
生产者消费者模型就显得没有说服力了。  
对于此模型，应该明确一下几点：
```
1、生产者仅仅在仓储未满时候生产，仓满则停止生产。

2、消费者仅仅在仓储有产品时候才能消费，仓空则等待。

3、当消费者发现仓储没产品可消费时候会通知生产者生产。

4、生产者在生产出可消费产品时候，应该通知等待的消费者去消费。
```

此模型将要结合java.lang.Object的wait与notify、notifyAll方法来实现以上的需求。这是非常重要的,在前文中
已经写过一个生产者消费者的程序来解说notifyAll(),有两行注释掉的notify(),是用notify()对于这种模型的实现。
以下是对此模型更详细的分析。

```
/** 
* Java线程：并发协作-生产者消费者模型
*/
public class Test {
        public static void main(String[] args) {
                Godown godown = new Godown(30);
                Consumer c1 = new Consumer(50, godown);
                Consumer c2 = new Consumer(20, godown);
                Consumer c3 = new Consumer(30, godown);
                Producer p1 = new Producer(10, godown);
                Producer p2 = new Producer(10, godown);
                Producer p3 = new Producer(10, godown);
                Producer p4 = new Producer(10, godown);
                Producer p5 = new Producer(10, godown);
                Producer p6 = new Producer(10, godown);
                Producer p7 = new Producer(80, godown);

                c1.start(); 
                c2.start(); 
                c3.start(); 
                p1.start(); 
                p2.start(); 
                p3.start(); 
                p4.start(); 
                p5.start(); 
                p6.start(); 
                p7.start(); 
        } 
} 

/** 
* 仓库 
*/ 
class Godown { 
        public static final int max_size = 100;//最大库存量
        public int curnum;    //当前库存量

        Godown() { 
        } 

        Godown(int curnum) {
                this.curnum = curnum;
        } 

        /** 
         * 生产指定数量的产品
         * 
         * @param neednum 
         */ 
        public synchronized void produce(int neednum) {
                //测试是否需要生产
                while (neednum + curnum > max_size) {
                        System.out.println("要生产的产品数量" + neednum +"超过剩余库存量" + (max_size - curnum) +"，暂时不能执行生产任务!");
                        try {
                                //当前的生产线程等待
                                wait(); 
                        } catch (InterruptedException e) {
                                e.printStackTrace(); 
                        } 
                } 
                //满足生产条件，则进行生产，这里简单的更改当前库存量
                curnum += neednum; 
                System.out.println("已经生产了" + neednum +"个产品，现仓储量为" + curnum);
                //唤醒在此对象监视器上等待的所有线程
                notifyAll(); 
        } 

        /** 
         * 消费指定数量的产品
         * 
         * @param neednum 
         */ 
        public synchronized void consume(int neednum) {
                //测试是否可消费
                while (curnum < neednum) {
                        try {
                                //当前的生产线程等待
                                wait(); 
                        } catch (InterruptedException e) {
                                e.printStackTrace(); 
                        } 
                } 
                //满足消费条件，则进行消费，这里简单的更改当前库存量
                curnum -= neednum; 
                System.out.println("已经消费了" + neednum +"个产品，现仓储量为" + curnum);
                //唤醒在此对象监视器上等待的所有线程
                notifyAll(); 
        } 
} 

/** 
* 生产者 
*/ 
class Producer extends Thread { 
        private int neednum;                //生产产品的数量
        private Godown godown;            //仓库

        Producer(int neednum, Godown godown) {
                this.neednum = neednum;
                this.godown = godown;
        } 

        public void run() {
                //生产指定数量的产品
                godown.produce(neednum); 
        } 
} 

/** 
* 消费者 
*/ 
class Consumer extends Thread { 
        private int neednum;                //生产产品的数量
        private Godown godown;            //仓库

        Consumer(int neednum, Godown godown) {
                this.neednum = neednum;
                this.godown = godown;
        } 

        public void run() {
                //消费指定数量的产品
                godown.consume(neednum); 
        } 
}
```

`说明：对于本例，要说明的是当发现不能满足生产或者消费条件的时候，调用对象的wait方法，
wait方法的作用是释放当前线程的所获得的锁，并调用对象的notifyAll()方法，通知（唤醒）该对象上其他等待线程，
使得其继续执行。这样，整个生产者、消费者线程得以正确的协作执行。notifyAll() 方法，起到的是一个通知作用，
不释放锁，也不获取锁。只是告诉该对象上等待的线程“可以竞争执行了，都醒来去执行吧”。本例中，如果消费者消费的仓储量达不到满足，
而又没有生产者，则程序会一直处于等待状态，这当然是不对的。实际上可以将此例进行修改，修改为，根据消费驱动生产，同时生产兼顾仓库，
如果仓不满就生产，并对每次最大消费量做个限制，这样就不存在此问题了，当然这样的例子更复杂，更难以说明这样一个简单模型。`

##### 9.5.2 死锁

>线程发生死锁可能性很小，即使看似可能发生死锁的代码，在运行时发生死锁的可能性也是小之又小。
发生死锁的原因一般是两个对象的锁相互等待造成的。

```
/** 
* 一个简单的死锁类 
* 当DeadLock类的对象flag==1时（td1），先锁定o1,睡眠500毫秒 
* 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2,睡眠500毫秒 
* td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定； 
* td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定； 
* td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。 
*/ 
public class DeadLock implements Runnable {  
    public int flag = 1;  
    //静态对象是类的所有对象共享的  
    private static Object o1 = new Object(), o2 = new Object();  
    @Override 
    public void run() {  
        System.out.println("flag=" + flag);  
        if (flag == 1) {  
            synchronized (o1) {  
                try {  
                    Thread.sleep(500);  
                } catch (Exception e) {  
                    e.printStackTrace();  
                }  
                synchronized (o2) {  
                    System.out.println("1");  
                }  
            }  
        }  
        if (flag == 0) {  
            synchronized (o2) {  
                try {  
                    Thread.sleep(500);  
                } catch (Exception e) {  
                    e.printStackTrace();  
                }  
                synchronized (o1) {  
                    System.out.println("0");  
                }  
            }  
        }  
    }  
   
    public static void main(String[] args) {  
           
        DeadLock td1 = new DeadLock();  
        DeadLock td2 = new DeadLock();  
        td1.flag = 1;  
        td2.flag = 0;  
        //td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。  
        //td2的run()可能在td1的run()之前运行  
        new Thread(td1).start();  
        new Thread(td2).start();  
   
    }  
}
```

[参考：多线程下并发同步机制](http://pluto418.iteye.com/blog/1179497)

#### 9.6 线程其他特征
##### 9.6.1 volatile关键字

Java™ 语言包含两种内在的同步机制：同步块（或方法）和 volatile变量。这两种机制的提出都是为了实现代码线程的安全性。
其中 Volatile变量的同步性较差（但有时它更简单并且开销更低），而且其使用也更容易出错。之所以要单独提出volatile这个不
常用的关键字原因是这个关键字在高性能的多线程程序中也有很重要的用途，只是这个关键字用不好会出很多问题。
volatile可以用在任何变量前面，但不能用于final变量前面，因为final型的变量是禁止修改的。也不存在线程安全的问题。
不多做介绍，仅提供一个比较好的博客  
[参考：正确使用 Volatile 变量](https://www.ibm.com/developerworks/cn/java/j-jtp06197.html)

##### 9.6.2 线程池

>线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理。
当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。
线程池有固定尺寸的线程池、可变尺寸连接池，需要了解java.util.concurrent.Executors类。

**一、固定大小的线程池**

```
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Test {
    public static void main(String[] args) {
            //创建一个可重用固定线程数的线程池
            ExecutorService pool = Executors.newFixedThreadPool(2); 
            //创建一个使用单个 worker线程的 Executor，以无界队列方式来运行该线程。
    	    //ExecutorService pool = Executors.newSingleThreadExecutor();
            //创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。
            //ExecutorService pool = Executors.newCachedThreadPool();
            //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口
            Thread t1 = new MyThread();
            Thread t2 = new MyThread();
            Thread t3 = new MyThread();
            Thread t4 = new MyThread();
            Thread t5 = new MyThread();
            //将线程放入池中进行执行
            pool.execute(t1); 
            pool.execute(t2); 
            pool.execute(t3); 
            pool.execute(t4); 
            pool.execute(t5); 
            //关闭线程池
            pool.shutdown(); 
    } 
}

class MyThread extends Thread{ 
        @Override 
        public void run() {
                System.out.println(Thread.currentThread().getName()+"正在执行。。。");
        } 
}
```

`运行结果：`

```
pool-1-thread-1正在执行。。。
pool-1-thread-2正在执行。。。
pool-1-thread-1正在执行。。。
pool-1-thread-2正在执行。。。
pool-1-thread-1正在执行。。。
```

**二、单任务线程池**
在上例的基础上改一行创建pool对象的代码为：  
`ExecutorService pool = Executors.newSingleThreadExecutor();`  
`运行结果：`  
```
pool-1-thread-1正在执行。。。
pool-1-thread-1正在执行。。。
pool-1-thread-1正在执行。。。
pool-1-thread-1正在执行。。。
pool-1-thread-1正在执行。。。
```  

>对于以上两种连接池，大小都是固定的，当要加入的池的线程（或者任务）超过池最大尺寸时候，则入此线程池需要排队等待。
一旦池中有线程完毕，则排队等待的某个线程会入池执行。  

**三、可变尺寸的线程池**

与上面的类似，只是改动下pool的创建方式：  
`ExecutorService pool = Executors.newCachedThreadPool();`  
`运行结果：`  
```
pool-1-thread-1正在执行。。。
pool-1-thread-4正在执行。。。
pool-1-thread-3正在执行。。。
pool-1-thread-5正在执行。。。
pool-1-thread-2正在执行。。。
```

**四、延迟连接池**

```
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class Test {
    public static void main(String[] args) {
            //创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。
            ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);
			//创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。  
			//ScheduledExecutorService pool = Executors.newSingleThreadScheduledExecutor();
            //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口
            Thread t1 = new MyThread();
            Thread t2 = new MyThread();
            Thread t3 = new MyThread();
            Thread t4 = new MyThread();
            Thread t5 = new MyThread();
            //将线程放入池中进行执行
            pool.execute(t1); 
            pool.execute(t2); 
            pool.execute(t3); 
            //使用延迟执行风格的方法
            pool.schedule(t4, 10000, TimeUnit.MILLISECONDS); 
            pool.schedule(t5, 1000, TimeUnit.MILLISECONDS); 
            //关闭线程池
            pool.shutdown(); 
    } 
}
```  
`运行结果：`  
```
pool-1-thread-1正在执行。。。
pool-1-thread-2正在执行。。。
pool-1-thread-1正在执行。。。
pool-1-thread-2正在执行。。。
pool-1-thread-1正在执行。。。
```

**五、单任务延迟连接池**

在上面代码基础上，做改动

//创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。  
`ScheduledExecutorService pool = Executors.newSingleThreadScheduledExecutor();`  
`运行结果：`  
```
pool-1-thread-1正在执行。。。
pool-1-thread-1正在执行。。。
pool-1-thread-1正在执行。。。
pool-1-thread-1正在执行。。。
pool-1-thread-1正在执行。。。
```

**六、自定义线程池**

```
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class Test {
    public static void main(String[] args) {
			/*BlockingQueue:阻塞队列，一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止。
            创建等待队列,若设置为3，则报错，总共为7个线程最大3个排队四个*/
            BlockingQueue<Runnable> bqueue = new ArrayBlockingQueue<Runnable>(4);
            //创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。
            ThreadPoolExecutor pool = new ThreadPoolExecutor(2,3,2,TimeUnit.MILLISECONDS,bqueue);
            //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口
            Thread t1 = new MyThread();
            Thread t2 = new MyThread();
            Thread t3 = new MyThread();
            Thread t4 = new MyThread();
            Thread t5 = new MyThread();
            Thread t6 = new MyThread();
            Thread t7 = new MyThread();
            //将线程放入池中进行执行
            pool.execute(t1); 
            pool.execute(t2); 
            pool.execute(t3); 
            pool.execute(t4); 
            pool.execute(t5); 
            pool.execute(t6); 
            pool.execute(t7); 
            //关闭线程池
            pool.shutdown(); 
    } 
} 
```  

`运行结果：`

```
pool-1-thread-1正在执行。。。
pool-1-thread-2正在执行。。。
pool-1-thread-3正在执行。。。
pool-1-thread-1正在执行。。。
pool-1-thread-3正在执行。。。
pool-1-thread-2正在执行。。。
pool-1-thread-1正在执行。。。
```

创建自定义线程池的构造方法很多，本例中参数的含义如下：

```
public ThreadPoolExecutor(int corePoolSize,

                         int maximumPoolSize,

                         long keepAliveTime,

                          TimeUnit unit,

                         BlockingQueue<Runnable> workQueue)
					 

用给定的初始参数和默认的线程工厂及处理程序创建新的ThreadPoolExecutor。使用Executors工厂方法之一比使用此通用构造方法方便得多。

参数：

corePoolSize -池中所保存的线程数，包括空闲线程。

maximumPoolSize -池中允许的最大线程数。

keepAliveTime -当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。

unit - keepAliveTime参数的时间单位。

workQueue -执行前用于保持任务的队列。此队列仅保持由execute方法提交的Runnable任务。

抛出：

IllegalArgumentException -如果 corePoolSize或 keepAliveTime小于零，或者 maximumPoolSize小于或等于零，或者 corePoolSize大于 maximumPoolSize。

NullPointerException -如果workQueue为 null
```	

**设置线程池大小：**

线程池究竟设成多大是要看你给线程池处理什么样的任务，任务类型不同，线程池大小的设置方式也是不同的。
任务一般可分为：CPU密集型、IO密集型、混合型，对于不同类型的任务需要分配不同大小的线程池。

* CPU密集型任务：尽量使用较小的线程池，一般为CPU核心数+1。 
因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。

* IO密集型任务：可以使用稍大的线程池，一般为2*CPU核心数。
IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。

* 混合型任务：可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。
只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。 
因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，
最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。

[参考：线程池使用实例](https://www.cnblogs.com/wihainan/p/4765862.html)

##### 9.6.3 线程返回值

**可返回值的任务必须实现Callable接口，类似的，无返回值的任务必须Runnable接口。**

`执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object。`

```
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Test {
    public static void main(String[] args)throws ExecutionException, InterruptedException {
            //创建一个线程池
            ExecutorService pool = Executors.newFixedThreadPool(2); 
            //创建两个有返回值的任务
            Callable c1 = new MyCallable("A");
            Callable c2 = new MyCallable("B");
            //执行任务并获取Future对象
            Future f1 = pool.submit(c1); 
            Future f2 = pool.submit(c2); 
            //从Future对象上获取任务的返回值，并输出到控制台
            System.out.println(">>>"+f1.get().toString());
            System.out.println(">>>"+f2.get().toString());
            //关闭线程池
            pool.shutdown(); 
    } 
}

import java.util.concurrent.Callable;

class MyCallable implements Callable{
    private String oid;

    MyCallable(String oid) { 
            this.oid = oid;
    } 

    @Override 
    public Object call()throws Exception {
            return oid+"任务返回的内容";
    } 
}
```

`运行结果：`

```
>>>A任务返回的内容
>>>B任务返回的内容
```

##### 9.6.4 读写锁

**1. 普通锁**

```
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Test {
    public static void main(String[] args) {
            //创建并发访问的账户
            MyCount myCount = new MyCount("95599200901215522", 10000);
            //创建一个锁对象
            Lock lock = new ReentrantLock();
            //创建一个线程池
            ExecutorService pool = Executors.newCachedThreadPool(); 
            //创建一些并发访问用户，一个信用卡，存的存，取的取，好热闹啊
            User u1 = new User("张三", myCount, -4000, lock); 
            User u2 = new User("张三他爹", myCount, 6000, lock); 
            User u3 = new User("张三他弟", myCount, -8000, lock); 
            User u4 = new User("张三", myCount, 800, lock);
            //在线程池中执行各个用户的操作
            pool.execute(u1); 
            pool.execute(u2); 
            pool.execute(u3); 
            pool.execute(u4); 
            //关闭线程池
            pool.shutdown(); 
    } 
}

import java.util.concurrent.locks.Lock;

/** 
* 信用卡的用户 
*/ 
class User implements Runnable { 
    private String name;                //用户名
    private MyCount myCount;        //所要操作的账户
    private int iocash;                //操作的金额，当然有正负之分了
    private Lock myLock;                //执行操作所需的锁对象

    User(String name, MyCount myCount, int iocash, Lock myLock) {
            this.name = name;
            this.myCount = myCount;
            this.iocash = iocash;
            this.myLock = myLock;
    } 

    public void run() {
            //获取锁
            myLock.lock(); 
            //执行现金业务
            System.out.println(name + "正在操作" + myCount +"账户，金额为" + iocash +"，当前金额为" + myCount.getCash());
            myCount.setCash(myCount.getCash() + iocash); 
            System.out.println(name + "操作" + myCount +"账户成功，金额为" + iocash +"，当前金额为" + myCount.getCash());
            //释放锁，否则别的线程没有机会执行了
            myLock.unlock(); 
    } 
} 

/** 
* 信用卡账户，可随意透支 
*/ 
class MyCount { 
        private String oid;        //账号
        private int cash;            //账户余额

        MyCount(String oid, int cash) {
                this.oid = oid;
                this.cash = cash;
        } 

        public String getOid() {
                return oid;
        } 

        public void setOid(String oid) {
                this.oid = oid;
        } 

        public int getCash() {
                return cash;
        } 

        public void setCash(int cash) {
                this.cash = cash;
        } 

        @Override 
        public String toString() {
                return"MyCount{" +
                                "oid='" + oid + '\'' +
                                ", cash=" + cash +
                                '}'; 
        } 
}
```

`运行结果：`

```
张三正在操作MyCount{oid='95599200901215522', cash=10000}账户，金额为-4000，当前金额为10000
张三操作MyCount{oid='95599200901215522', cash=6000}账户成功，金额为-4000，当前金额为6000
张三他爹正在操作MyCount{oid='95599200901215522', cash=6000}账户，金额为6000，当前金额为6000
张三他爹操作MyCount{oid='95599200901215522', cash=12000}账户成功，金额为6000，当前金额为12000
张三他弟正在操作MyCount{oid='95599200901215522', cash=12000}账户，金额为-8000，当前金额为12000
张三他弟操作MyCount{oid='95599200901215522', cash=4000}账户成功，金额为-8000，当前金额为4000
张三正在操作MyCount{oid='95599200901215522', cash=4000}账户，金额为800，当前金额为4000
张三操作MyCount{oid='95599200901215522', cash=4800}账户成功，金额为800，当前金额为4800
```

在上文中提到了Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为`普通锁`。
为了提高性能，Java提供了`读写锁`，在读的地方使用读锁，在写的地方使用写锁，灵活控制，在一定程度上提高了程序的执行效率。

**2. 读写锁**

```
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/** 
* Java线程：读写锁 
* 
* @author leizhimin 2009-11-5 10:57:29 
*/ 
public class Test {
        public static void main(String[] args) {
                //创建并发访问的账户
                MyCount myCount = new MyCount("95599200901215522", 10000);
                //创建一个锁对象
                ReadWriteLock lock = new ReentrantReadWriteLock(false);
                //创建一个线程池
                ExecutorService pool = Executors.newFixedThreadPool(2); 
                //创建一些并发访问用户，一个信用卡，存的存，取的取，好热闹啊
                User u1 = new User("张三", myCount, -4000, lock, false); 
                User u2 = new User("张三他爹", myCount, 6000, lock, false); 
                User u3 = new User("张三他弟", myCount, -8000, lock, false); 
                User u4 = new User("张三", myCount, 800, lock,false); 
                User u5 = new User("张三他爹", myCount, 0, lock,true); 
                //在线程池中执行各个用户的操作
                pool.execute(u1); 
                pool.execute(u2); 
                pool.execute(u3); 
                pool.execute(u4); 
                pool.execute(u5); 
                //关闭线程池
                pool.shutdown(); 
        } 
} 

import java.util.concurrent.locks.ReadWriteLock;

/** 
* 信用卡的用户 
*/ 
class User implements Runnable { 
        private String name;                //用户名
        private MyCount myCount;        //所要操作的账户
        private int iocash;                //操作的金额，当然有正负之分了
        private ReadWriteLock myLock;                //执行操作所需的锁对象
        private boolean ischeck;        //是否查询

        User(String name, MyCount myCount, int iocash, ReadWriteLock myLock,boolean ischeck) {
                this.name = name;
                this.myCount = myCount;
                this.iocash = iocash;
                this.myLock = myLock;
                this.ischeck = ischeck;
        } 

        public void run() {
                if (ischeck) {
                        //获取读锁
                        myLock.readLock().lock(); 
                        System.out.println("读：" + name +"正在查询" + myCount +"账户，当前金额为" + myCount.getCash());
                        //释放读锁
                        myLock.readLock().unlock(); 
                } else {
                        //获取写锁
                        myLock.writeLock().lock(); 
                        //执行现金业务
                        System.out.println("写：" + name +"正在操作" + myCount +"账户，金额为" + iocash +"，当前金额为" + myCount.getCash());
                        myCount.setCash(myCount.getCash() + iocash); 
                        System.out.println("写：" + name +"操作" + myCount +"账户成功，金额为" + iocash +"，当前金额为" + myCount.getCash());
                        //释放写锁
                        myLock.writeLock().unlock(); 
                } 
        } 
} 

/** 
* 信用卡账户，可随意透支 
*/ 
class MyCount { 
        private String oid;        //账号
        private int cash;            //账户余额

        MyCount(String oid, int cash) {
                this.oid = oid;
                this.cash = cash;
        } 

        public String getOid() {
                return oid;
        } 

        public void setOid(String oid) {
                this.oid = oid;
        } 

        public int getCash() {
                return cash;
        } 

        public void setCash(int cash) {
                this.cash = cash;
        } 

        @Override 
        public String toString() {
                return"MyCount{" +
                                "oid='" + oid + '\'' +
                                ", cash=" + cash +
                                '}'; 
        } 
}
```

`运行结果`

```
写：张三正在操作MyCount{oid='95599200901215522', cash=10000}账户，金额为-4000，当前金额为10000
写：张三操作MyCount{oid='95599200901215522', cash=6000}账户成功，金额为-4000，当前金额为6000
写：张三他爹正在操作MyCount{oid='95599200901215522', cash=6000}账户，金额为6000，当前金额为6000
写：张三他爹操作MyCount{oid='95599200901215522', cash=12000}账户成功，金额为6000，当前金额为12000
写：张三他弟正在操作MyCount{oid='95599200901215522', cash=12000}账户，金额为-8000，当前金额为12000
写：张三他弟操作MyCount{oid='95599200901215522', cash=4000}账户成功，金额为-8000，当前金额为4000
写：张三正在操作MyCount{oid='95599200901215522', cash=4000}账户，金额为800，当前金额为4000
写：张三操作MyCount{oid='95599200901215522', cash=4800}账户成功，金额为800，当前金额为4800
读：张三他爹正在查询MyCount{oid='95599200901215522', cash=4800}账户，当前金额为4800
```

`在实际开发中，最好在能用读写锁的情况下使用读写锁，而不要用普通锁，以求更好的性能。`

[参考：synchronized和读写锁的区别](http://blog.csdn.net/it_man/article/details/8972001)

##### 9.6.5 障碍器

`当所有子任务都执行完成时候，才能执行主任务，这时候，就可以选择障碍器了。障碍器是多线程并发控制的一种手段。`

```
import java.util.concurrent.CyclicBarrier;

/** 
* Java线程：新特征-障碍器
* 
*/ 
public class Test {
        public static void main(String[] args) {
                //创建障碍器，并设置MainTask为所有定数量的线程都达到障碍点时候所要执行的任务(Runnable)
                CyclicBarrier cb = new CyclicBarrier(7,new MainTask());
                new SubTask("A", cb).start();
                new SubTask("B", cb).start();
                new SubTask("C", cb).start();
                new SubTask("D", cb).start();
                new SubTask("E", cb).start();
                new SubTask("F", cb).start();
                new SubTask("G", cb).start();
        } 
} 

/** 
* 主任务 
*/ 
class MainTask implements Runnable { 
        public void run() {
                System.out.println(">>>>主任务执行了！<<<<");
        } 
} 

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/** 
* 子任务 
*/ 
class SubTask extends Thread { 
        private String name;
        private CyclicBarrier cb;

        SubTask(String name, CyclicBarrier cb) { 
                this.name = name;
                this.cb = cb;
        } 

        public void run() {
                System.out.println("[子任务" + name +"]开始执行了！");
                for (int i = 0; i < 999999; i++) ;    //模拟耗时的任务
                System.out.println("[子任务" + name +"]开始执行完成了，并通知障碍器已经完成！");
                try {
                        //通知障碍器已经完成
                        cb.await(); 
                } catch (InterruptedException e) {
                        e.printStackTrace(); 
                } catch (BrokenBarrierException e) {
                        e.printStackTrace(); 
                } 
        } 
}
```

`运行结果：`

```
[子任务A]开始执行了！
[子任务B]开始执行了！
[子任务C]开始执行了！
[子任务G]开始执行了！
[子任务G]开始执行完成了，并通知障碍器已经完成！
[子任务D]开始执行了！
[子任务F]开始执行了！
[子任务F]开始执行完成了，并通知障碍器已经完成！
[子任务C]开始执行完成了，并通知障碍器已经完成！
[子任务B]开始执行完成了，并通知障碍器已经完成！
[子任务A]开始执行完成了，并通知障碍器已经完成！
[子任务E]开始执行了！
[子任务E]开始执行完成了，并通知障碍器已经完成！
[子任务D]开始执行完成了，并通知障碍器已经完成！
>>>>主任务执行了！<<<<
```

从执行结果可以看出，所有子任务完成的时候，主任务执行了，达到了控制的目标。


