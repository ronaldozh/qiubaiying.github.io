---
layout:     post
title:      Java多线程
subtitle:   详细分析及多个案例
date:       2017-10-13
author:     赵小恒
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
    - 多线程
---

>JSON转模型是我们做iOS开发的基础技能，本文将通过[YYModel](https://github.com/ibireme/YYModel)这个框架安全快速的完成JSON到模型的转换，其中还会介绍到一款好用的插件[ESJsonFormat](https://github.com/EnjoySR/ESJsonFormat-Xcode)。

### 1、概念与原理

#### 1.1操作系统中线程和进程的概念

现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。
线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。 “同时”执行是人的感觉，在线程之间实际上轮换执行。

#### 1.2Java中的线程

在Java中，“线程”指两件不同的事情：
1、java.lang.Thread类的一个实例；
2、线程的执行。
使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义、实例化和启动新线程。
一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。
Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。
一个Java应用总是从main()方法开始运行，mian()方法运行在一个线程内，它被称为主线程。
一旦创建一个新的线程，就产生一个新的调用栈。

### 2、创建与启动

#### 2.1定义线程

- 2.1.1扩展java.lang.Thread类:
- 2.1.2实现java.lang.Runnable接口：

#### 2.2创建实例并启动
```java
/**
 * 此种方式为扩展java.lang.Thread类
 * 
 */
public class Test extends Thread { 
	
	/**
	 * 构造方法初始化属性
	 * @param name
	 */
	public Test(String name){
	
            super(name);
        }
	
	public static void main(String[] args){
		 
		//创建一个线程：
		Test test1 = new Test("线程1");
		test1.start();// 启动一个线程

		Test test2 = new Test("线程2");
		test2.start();// 启动一个线程

	 }
	/**
	 *  run方法是多线程的业务方法
	 */
	public void run() {
		while (true) {
			System.out.println(Thread.currentThread().getName());
		}
	}

}
```
```java
/**
 * 此种方式为实现Runnable接口的多线程
 * 
 */
public class Test implements Runnable {

    private String name;
    /**
    * 构造方法初始化属性
    * @param name
    */
    public Test(String name) {
        this.name = name;
    } 

    public void run() {
    	while (true) {
			System.out.println(name);
		}
    } 
	
    public static void main(String[] args){
		 
	// 创建线程7：
	Test test1 = new Test("线程1--------------");
	Thread t1 = new Thread(test1);
	t1.start();// 启动一个线程

	Test test2 = new Test("线程2+++++++++++++");
	Thread t2 = new Thread(test2);
	t2.start();// 启动一个线程
    }

}	
```

### 3、一些常见问题

（1）线程的名字，一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，
虚拟机总会为线程指定名字，并且主线程的名字总是mian，非主线程的名字不确定。

（2）线程都可以设置名字，也可以获取线程的名字，连主线程也不例外。

（3）获取当前线程的对象的方法是：Thread.currentThread()。

（4）在上面的代码中，只能保证：每个线程都将启动，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按该顺序执行。
     对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。

（5）当线程目标run()方法结束时该线程完成。

（6）一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次。一个可运行的线程或死线程可以被重新启动。

（7）线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。
     众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的。

（8）尽管通常采用队列形式（先进先出的数据存储方式），但这是没有保障的。队列形式是指当一个线程完成“一轮”时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，
   它才能被再次选中。事实上，我们把它称为可运行池而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列而成一个一个队列的事实。

（9）尽管我们无法控制线程调度程序，但可以通过别的方式来影响线程调度。

### 4、线程栈模型

要理解线程调度的原理，以及线程执行过程，必须理解线程栈模型。
线程栈是指某时刻时内存中线程调度的栈信息，当前调用的方法总是位于栈顶。线程栈的内容是随着程序的运行动态变化的，
因此研究线程栈必须选择一个运行的时刻（实际上指代码运行到什么地方)。
下面通过一个示例性的代码说明线程（调用）栈的变化过程。
![](/img/duoxiancheng/zh-xczmx.jpg)
虚拟机线程调用栈示意图:
程序执行到(1)时，栈中只有一个main方法，执行到（2）时，会先把println方法装进来，等打印完成再释放出去，
执行到（3），会把Test的构造函数装进来，构造完成再释放出去，再把method方法装进来，依次类推，执行到（4），
会开辟一个新栈，单独执行run方法，之前的装着main方法的栈依然独立存在运行着，与装着run方法的栈不发生冲突，
程序多出一个分支（增加了一个装着run方法的调用栈），他们并行执行。从这里就可以看出方法调用和线程启动的区别了。


### 5、线程状态的转换

#### 5.1线程状态

线程的状态转换是线程控制的基础。线程状态总的可以分为五大状态。用一个图来描述如下：
![](/img/duoxiancheng/zh-xczt.png)
（1）新状态：线程对象已经创建，还没有在其上调用start()方法。

（2）可运行状态：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，
     线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。
	 
（3）运行状态：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。

（4）等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，
     但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态。
	 
（5）死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。
     线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。

然后点击`Window`->`ESJsonFormat`->`Input JSON Window`调出窗口

#### 5.2阻止线程执行
>对于线程的阻止，考虑一下三个方面，不考虑IO阻塞的情况：
- sleep()；
- yield()；
- join()。

（5.2.1）sleep()：
Thread.sleep(longmillis)和Thread.sleep(long millis, int nanos)静态方法强制当前正在执行的线程休眠（暂停执行），
以“减慢线程”。当线程睡眠时，它入睡在某个地方，在苏醒之前不会返回到可运行状态。当睡眠时间到期，则返回到可运行状态。
```java
public class Test extends Thread {

	public void run(){  
	       for(int i=0;i<100;i++){  
	           if ((i)%10==0) {  
	              System.out.println("--------"+i);  
	           }  
	           System.out.print(i);  
	           try {  
	              Thread.sleep(1000);  
	              System.out.print("    线程睡眠1秒！\n");  
	           } catch (InterruptedException e) {  
	              e.printStackTrace();  
	           }  
	       }  
	    }  
	   
	    public static void main(String[] args) {  
	       new Test().start();  
	    }  

}
```
>注意：
1、线程睡眠是帮助所有线程获得运行机会的最好方法。
2、线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态。sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行。
3、sleep()是静态方法，只能控制当前正在运行的线程。

（5.2.2）yield()：
线程的让步是通过Thread.yield()来实现的。yield()方法的作用是：暂停当前正在执行的线程对象，并执行其他线程。
要理解yield()，必须了解线程的优先级的概念。线程总是存在优先级，优先级范围在1~10之间。JVM线程调度程序是基于优先级的抢先调度机制。
在大多数情况下，当前运行的线程优先级将大于或等于线程池中任何线程的优先级。但这仅仅是大多数情况。
>注意：当设计多线程应用程序的时候，一定不要依赖于线程的优先级。因为线程调度优先级操作是没有保障的，
       只能把线程优先级作用作为一种提高程序效率的方法，但是要保证程序不依赖这种操作。
       当线程池中线程都具有相同的优先级，调度程序的JVM实现自由选择它喜欢的线程。这时候调度程序的操作有两种可能：
	   一是选择一个线程运行，直到它阻塞或者运行完成为止。二是时间分片，为池内的每个线程提供均等的运行机会。

设置线程的优先级：线程默认的优先级是5。可以通过setPriority(int newPriority)更改线程的优先级.线程优先级为1~10之间的正整数，
JVM从不会改变一个线程的优先级。然而，1~10之间的值是没有保证的。一些JVM可能不能识别10个不同的值，而将这些优先级进行每两个或多个合并，
变成少于10个的优先级，则两个或多个优先级的线程可能被映射为一个优先级。
```java
Thread t = new MyThread();  
t.setPriority(8);  
t.start();
```
Thread类中有三个常量，定义线程优先级范围：
```java
static intMAX_PRIORITY：线程可以具有的最高优先级。  
static intMIN_PRIORITY：线程可以具有的最低优先级。  
static intNORM_PRIORITY：分配给线程的默认优先级。 
```
yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。
但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。
>注意：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。

（5.2.3）join()：  
```java
public static void main(String[] args){
    
    System.out.println("main start");
    Thread t1 = new Thread(new Worker("thread-1"));
    t1.start();
    t1.join();
    System.out.println("main end");
}
``` 
在上面的例子中，main线程要等到t1线程运行结束后，才会输出“main end”。如果不加t1.join(),main线程和t1线程是并行的。而加上t1.join(),程序就变成是顺序执行了。
另外，join()方法还有带超时限制的重载版本。例如t.join(5000);则让线程等待5000毫秒，如果超过这个时间，则停止等待，变为可运行状态。

>小结:到目前位置，介绍了线程离开运行状态的3种方法：
(1)、调用Thread.sleep()：使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）。
(2)、调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。
(3)、调用join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。
除了以上三种方式外，还有下面几种特殊情况可能使线程离开运行状态：
(1)、线程的run()方法完成。
(2)、在对象上调用wait()方法（不是在线程上调用）。
(3)、线程不能在对象上获得锁定，它正试图运行该对象的方法代码。
(4)、线程调度程序可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由。 

### 6、线程的同步与锁

#### 6.1同步问题提出
>线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏。
例如：两个线程ThreadA、ThreadB都操作同一个对象Foo对象，并修改Foo对象上的数据。

```java
public class Foo {  
    private int x = 100;  
    public int getX() {  
        return x;  
    }  
    public int fix(int y) {  
        x = x - y;  
        return x;  
    }  
}

public class FooRunnable implements Runnable {  
    private Foo foo =new Foo();  
   
    public static void main(String[] args) {  
       FooRunnable r = new FooRunnable();  
        Thread ta = new Thread(r,"Thread-A");  
        Thread tb = new Thread(r,"Thread-B");  
        ta.start();  
        tb.start();  
    }  
   
    @Override  
    public void run() {  
       for (int i = 0; i < 3; i++) {  
            this.fix(30);  
            try {  
                Thread.sleep(1);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
            System.out.println(Thread.currentThread().getName()+ " :当前foo对象的x值= " + foo.getX());  
        }  
    }  
   
    public int fix(int y) {  
       return foo.fix(y);  
    }  
}
```
>执行结果:

```java
Thread-A :当前foo对象的x值= 10
Thread-A :当前foo对象的x值= -20
Thread-B :当前foo对象的x值= -20
Thread-B :当前foo对象的x值= -50
Thread-B :当前foo对象的x值= -800
```

>从结果发现，这样的输出值明显是不合理的，原因是两个线程不加控制的访问Foo对象并修改其数据所致。如果要保持结果的合理性，只需要达到一个目的，
就是将对Foo的访问加以限制，每次只能有一个线程在访问。这样就能保证Foo对象中数据的合理性了。
在具体的Java代码中需要完成以下两个操作：
把竞争访问的资源类Foo变量x标识为private；
同步修改变量的代码，使用synchronized关键字同步方法或代码。

#### 6.2同步和锁定
>锁的原理：
        Java中每个对象都有一个内置锁。java内置锁是一个互斥锁。
        当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。
		获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。
        当程序运行到synchronized同步方法或代码块时才该对象锁才起作用。
        一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。
		这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。
        释放锁是指持锁线程退出了synchronized同步方法或代码块。

        关于锁和同步，有一下几个要点：

        1）只能同步方法，而不能同步变量和类；

        2）每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？

        3）不必同步类中所有的方法，类可以同时拥有同步和非同步方法。

        4）如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，
	       那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：如果一
	       个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。

        5）如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。

        6）线程睡眠时，它所持的任何锁都不会释放。

        7）线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，
		   则获取了两个对象的同步锁。

        8）同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，
		   还可以同步方法中一部分代码块。

        9）在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。例如：
		
```java
    public int fix(int y) {  
		
        synchronized (this) {  
            x = x - y;  
        }  
        return x;  
    }  
```		
当然，同步方法也可以改写为非同步方法，但功能完全一样的，例如：
```java
    public synchronized int getX() {  
	
        return x++;  
    }
```
与
```java
    public int getX() {  
	
        synchronized (this) {  
            return x;  
        }  
    }  
```
效果是完全一样的。

#### 6.3静态方法同步
要同步静态方法，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class)。
例如：
```java
    public static synchronized int getName(String name){  
       
    }  
```   
等价于
```java
    public static int getName(String name){  
        synchronized(Test.class){  
            
        }  
    } 
```
>注意：在使用synchronized块来同步方法时，非静态方法可以通过this来同步，而静态方法必须使用class对象来同步，
但是非静态方法也可以通过使用class来同步静态方法。但是静态方法中不能使用this来同步非静态方法。这点在使用synchronized块需要注意。

#### 6.4如果线程不能获得锁会怎么样
>如果线程试图进入同步方法，而其锁已经被占用，则线程在该对象上被阻塞。实质上，线程进入该对象的一种池中，必须在那里等待，直到其锁被释放，该线程再次变为可运行或运行为止。
 考虑阻塞时，一定要注意哪个对象正被用于锁定：

    1、调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，
	   则每个线程有自己的对象的锁，线程间彼此互不干预。

    2、调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。

    3、静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，
	   非静态方法锁定在该类的对象上。

    4、对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。
	   在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞。
		   
#### 6.5何时需要同步
>在多个线程同时访问互斥（可交换）数据时，应该同步以保护数据，确保两个线程不会同时修改更改它。如果是共享数据，则不需要同步。
对于非静态字段中可更改的数据，通常使用非静态方法访问。
对于静态字段中可更改的数据，通常使用静态方法访问。

#### 6.6线程安全类
>当一个类已经很好的同步以保护它的数据时，这个类就称为“线程安全的”。
即使是线程安全类，也应该特别小心，因为操作的线程之间仍然不一定安全。

举个形象的例子，比如一个集合是线程安全的，有两个线程在操作同一个集合对象，当第一个线程查询集合非空后，
删除集合中所有元素的时候。第二个线程也来执行与第一个线程相同的操作，也许在第一个线程查询后，
第二个线程也查询出集合非空，但是当第一个执行清除后，第二个再执行删除显然是不对的，因为此时集合已经为空了。
解决方法为在操作的方法上添加同步，这样，当一个线程访问其中一个同步方法时，其他线程只有等待。

```java
public class NameList {

    //创造线程安全的集合类
    private List nameList = Collections.synchronizedList(new LinkedList());  
	   
    public void add(String name) {  
        nameList.add(name);  
    }  
   
    public String removeFirst() {  
       if (nameList.size()>0) {  
    	   try {
    		   	//让线程睡眠1秒，创造两个线程都读取到数据的场景
			    Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
    	   return (String) nameList.remove(0); 
       } else {  
           return null;  
       }  
    }    
}
```
```java
public class TestNameList {
	
    public static void main(String[] args) {  
        final NameList nl =new NameList();  
         nl.add("苏东坡");  
         class NameDropper extends Thread{  
           @Override  
           public void run() {
              String name = nl.removeFirst();  
                System.out.println(name);  
           }          
         }  
         Thread t1=new NameDropper();  
         Thread t2=new NameDropper();  
         t1.start(); 
         t2.start();  
    }  
}
```
运行结果：
```java
苏东坡
Exception in thread "Thread-1" java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
	at java.util.LinkedList.checkElementIndex(LinkedList.java:553)
	at java.util.LinkedList.remove(LinkedList.java:523)
	at java.util.Collections$SynchronizedList.remove(Collections.java:1888)
	at NameList.removeFirst(NameList.java:20)
	at TestNameList$1NameDropper.run(TestNameList.java:10)
```
结果是报错了，虽然集合对象
```java
    private List nameList =Collections.synchronizedList(new LinkedList());  
```
是同步的，但是程序还不是线程安全的。出现这种事件的原因是，上例中一个线程操作列表过程中无法阻止另外一个线程对列表的其他操作。
解决上面问题的办法是，在操作集合对象nameList上面做一个同步。改写后的代码如下：
```java
public class NameList { 
 
    private List nameList = Collections.synchronizedList(new LinkedList());  
   
    public synchronized void add(String name) {  
        nameList.add(name);  
    }  
   
    public synchronized String removeFirst() {  
    	if (nameList.size()>0) {  
     	   try {
 			    Thread.sleep(1000);
 			} catch (InterruptedException e) {
 				e.printStackTrace();
 			}
     	   return (String) nameList.remove(0); 
        } else {  
            return null;  
        }   
       
    }    
}
```
### 7、线程死锁
>死锁对Java程序来说，是很复杂的，也很难发现问题。当一个线程被阻塞，另一个线程在等待阻塞的线程时就发生死锁。		
```java
class Lock1 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock1 running");
            while(true){
                synchronized(DeadLock.obj1){
                    System.out.println("Lock1 lock obj1");
                    Thread.sleep(3000);//获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2
                    synchronized(DeadLock.obj2){
                        System.out.println("Lock1 lock obj2");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```
```java
class Lock2 implements Runnable{
    @Override
    public void run(){
        try{
            System.out.println("Lock2 running");
            while(true){
                synchronized(DeadLock.obj2){
                    System.out.println("Lock2 lock obj2");
                    Thread.sleep(3000);
                    synchronized(DeadLock.obj1){
                        System.out.println("Lock2 lock obj1");
                    }
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```
```java
public class DeadLock {
    public static String obj1 = "obj1";
    public static String obj2 = "obj2";
    public static void main(String[] args){
        Thread a = new Thread(new Lock1());
        Thread b = new Thread(new Lock2());
        a.start();
        b.start();
    }    
}
```
运行结果：
```java
Lock1 running
Lock2 running
Lock1 lock obj1
Lock2 lock obj2
```
线程a锁住变量obj1，线程b锁住变量obj2，线程a就没办法锁住obj2，线程b也没办法锁住obj1，这时就陷入了死锁。

### 8.线程同步小结

```ruby
1、线程同步的目的是为了保护多个线程访问同一个资源时对资源的破坏。

2、线程同步方法是通过锁来实现，每个对象都有且仅有一个锁，这个锁与一个特定的对象关联，
线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。

3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。
静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，
会获取这两个对象锁。

4、对于同步，要时刻清醒在哪个对象上同步，这是关键。

5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，
对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。

6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。

7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。

```
### 9.线程的交互
#### 9.1线程交互的基础知识		
>线程交互知识点需要从java.lang.Object的类的三个方法来学习：

```
(1)void notify()——唤醒在此对象监视器上等待的单个线程。  
(2)void notifyAll()——唤醒在此对象监视器上等待的所有线程。  
(3)void wait()——导致当前的线程等待，直到其他线程调用此对象的 notify()方法或 notifyAll()方法。
```

>当然，wait()还有另外两个重载方法：


**(1)void wait(longtimeout)——导致当前的线程等待，直到其他线程调用此对象的 notify()方法
或 notifyAll()方法，或者超过指定的时间量。** 
**(2)void wait(longtimeout, int nanos)——导致当前的线程等待，直到其他线程调用此对象的 
notify()方法或 notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。** 
		
```
public class ThreadA {  
    public static void main(String[] args) {  
       ThreadB b=new ThreadB();  
       //启动计算线程  
       b.start();  
       //线程A拥有b对象上的锁。线程为了调用wait()或notify()方法，该线程必须是那个对象锁的拥有者  
       synchronized (b) {  
           try {  
              System.out.println("等待对象b完成计算......");  
              b.wait();  
           } catch (Exception e) {  
              e.printStackTrace();  
           }  
           System.out.println("b对象计算的总和是：" + b.total);  
       }  
    }  
}

public class ThreadB extends Thread {  
    int total;  
    public void run(){  
       synchronized (this) {  
    	     
           for (int i=0;i<101;i++){  
              total+=i;  
           }  
           //（完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程A被唤醒  
           notify();
       }  
    }  
}
```

执行结果：

```
等待对象b完成计算......
b对象计算的总和是：5050
```

**千万注意：
当在对象上调用wait()方法时，执行该代码的线程立即放弃它在对象上的锁。
然而调用notify()时，并不意味着这时线程会放弃其锁。如果线程仍然在完成同步代码，
则线程在移出之前不会放弃锁。因此，只要调用notify()并不意味着这时该锁变得可用。**

[这里附上一篇wait与notify的详解](http://blog.csdn.net/lingzhm/article/details/44940823)
[加深理解的另一篇博文](http://blog.163.com/sunflower123_happy/blog/static/17327442120112264383864/)





		

![](http://ww1.sinaimg.cn/large/006y8lVagw1f95tr49ed7j30no0csdir.jpg)

在窗口中输入你要解析的JSON文本，如下图：

![](http://ww4.sinaimg.cn/large/006y8lVagw1f97s13l4b9j30jv0e8dhp.jpg)

按`Enter`继续，然后神奇的一幕发生了

![](http://ww3.sinaimg.cn/large/006y8lVagw1f97s46k95tj30k30dydj9.jpg)

![](http://ww1.sinaimg.cn/large/006y8lVagw1f97s6yp9hmj30iw0b840m.jpg)

看到在.h中 所有的属性自动为你填上，而且帮你选好了类型

.m 也为你声明了`list`中成员的类型，不过这里需要稍作修改，因为我们需要用到YYModel进行解析，所以方法名改成`modelContainerPropertyGenericClass`

```
+ (NSDictionary *)modelContainerPropertyGenericClass {
    return @{@"list" : [List class]};
}

```

还有问题就是属性中出现关键字`id`，我们需要将id改为`teacherId`

然后在.m的`implementation`中声明,将字典的的`id`

```
+ (NSDictionary *)modelCustomPropertyMapper {
    return @{@"teacherId" : @"id"};
}
```

这样，模型的创建就完成了，剩下的就是用YYModel进行解析了

# 2、使用YYModel进行解析

解析很简单，就只需要一句话

```
// 将 JSON (NSData,NSString,NSDictionary) 转换为 Model:
Model *model = [Model yy_modelWithJSON:json];

// 或者
Model *model = [[Model alloc] init];
[model yy_modelSetWithDictionary:json];

```

到此，简便快速的完成了JSON到模型的转换。


最后，[这里附上一篇YYModel的使用](http://www.jianshu.com/p/25e678fa43d3)