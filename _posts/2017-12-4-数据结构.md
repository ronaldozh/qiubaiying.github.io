---
layout:     post
title:      数据结构
subtitle:   笔记
date:       2017-12-4
author:     赵小恒
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - 数据结构
---

### 1、基本概念和术语

#### 1.1 数据

数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机
处理的符号集合。数据不仅仅包括整型，实型等数值类型，还包括字符、声音、图像、视频等非数值类型。

#### 1.2 数据元素

数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。在人类
中，什么是数据元素？当然是人了。畜类呢？诸如牛、马、羊等动物就是畜类的数据元素。

#### 1.3 数据项

数据项：一个数据元素可以由若干个数据项组成。比如人这样的数据元素，可以有眼、耳、鼻、手等这些数据项，
也可以有姓名、年龄、性别等数据项，具体有哪些数据项，要视你做的系统来决定。`数据项是数据不可分割的最小单位`。
真正讨论问题时，数据元素才是数据结构中建立数据模型的重点。就像我们讨论一部电影时，是讨论电影角色这样的“数据元素”，
而不是这对这个角色的姓名或者年龄这样的“数据项”去研究分析。

#### 1.4 数据对象

数据对象：是性质相同的数据元素的集合，是数据的子集。什么叫性质相同呢，是指数据元素具有相同数量和类型的数据项，比如，人
都有姓名、生日、性别等相同的数据项。  
既然数据对象是数据的子集，在实际应用中，处理的数据元素通常具有相同性质，在不产生混淆的情况下，我们都将数据对象简称为数据。

#### 1.5 数据结构

数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的
数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。

#### 1.6 逻辑结构与物理结构

>按照视点的不同，我们把数据结构分为逻辑结构和物理结构

##### 1.6.1 逻辑结构

定义：是指数据对象中数据元素之间的相互关系。这也是我们今后需要关心的问题。逻辑结构共分为四种：

**1.集合结构**

定义：集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。各个元素是平等的（如下图）。

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_1.jpg)

**2.线性结构**

定义：线性结构中的数据元素之间是一对一的关系（如下图）。

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_2.jpg)

**3.树形解构**

定义：树形解构中的数据元素之间存在一种一对多的层次关系（如下图）。

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_3.jpg)

**4.图形结构**

定义：图形结构的元素是多对多的关系（如下图）。

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_4.jpg)

##### 1.6.2 物理结构

定义：是指数据的逻辑结构在计算机中的存储形式。也称存储结构。实际上就是如何把数据元素存储到计算机的存储器中。
存储器主要针对内存，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。数据元素的存储结构有两种：
顺序存储于链式存储。

**1. 顺序存储结构**

定义:是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。

这种存储结构其实很简单，就是排队占位。大家都按顺序排好，每个人占一小段空间，大家谁也别插谁的队。数组就是这样的，
顺序存储结构(如下图)。

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5.jpg)

**2.链式存储结构**

如果就是这么简单和有规律，一切就好办了。可实际上，总会有人插队，也会有人要上厕所、有人会放弃排队。所以这个队伍当中
会添加新成员，也有可能会去掉老元素，整个结构时刻都处于变化中。显然，面对这样时常要变化的结构，顺序存储是不科学的，那怎么办呢？
这就需要链式存储了。

定义：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此
需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置（如下图）

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6.jpg)

显然，链式存储就灵活多了，数据存在哪里不重要，只要有一个指针存放了相应的地址就能找到它了。

现在如医院、银行等地方，设置了排队系统，也就是每个人先领一个号，等着叫号，叫到时去办理业务或看病。在等待的时候，你爱在哪都可以。你关注的
是前一个号有没有被叫到，叫到了，下一个就轮到了。

#### 1.7 抽象数据类型
##### 1.7.1 数据类型

数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

##### 1.7.2 抽象数据类型

抽象数据类型：是指一个数学模型及定义在该模型上的一组操作。

#### 1.8 总结

数据结构相关概念（如下图）

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7.jpg)

数据结构分为逻辑结构与物理结构（也叫存储结构）（如下图）

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_8.jpg)

### 2、算法

定义：普遍认可的算法定义是：解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，
并且每条指令表示一个或多个操作。

#### 2.1 算法的特性

+ 输入输出：算法具有零个或多个输，至少有一个或多个输出。入打印“hello,world!”,这样的代码不需要任何参数，若
没输出，你用这个算法干嘛？输出的形式可以是打印输出，也可以是返回值形式等。

+ 有穷性：指算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。

+ 确定性：算法的每一步骤都具有确定的含义，不会出现二义性。

+ 可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

#### 2.2 算法设计的要求

+ 证确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。

+ 可读性：算法设计的另一目的是为了便于阅读、理解和交流。

+ 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。
+ 时间效率高和存储量低。

#### 2.3 算法效率的度量方法

+ 事后统计方法：这种方法主要是通过设计好的程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法
效率的高低。

+ 事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。

下面实际例子分析

问题描述：`求和1+2+...+100`

**1.第一种算法**
{% highlight java %}
int i,sum=0,n=100;//执行1次
for(int i=1;i<n;i++){//执行n+1次
	sum = sum + i;//执行n次
}
System.out.println(sum);//执行1次
{% endhighlight %}

**2.第二种算法**

{% highlight java %}
int sum=0,n=100;//执行1次
sum = (1 + n) * n / 2;//执行1次
System.out.println(sum);//执行1次
{% endhighlight %}

结论：第一种算法执行了1+（n+1）+n+1=2n+3次；而第二种算法是3次，去掉收尾语句及第一个算法的
判断次数的开销，我们关注的代码就是中间的部分，也就是n次与1次的差距，算法好坏显而易见。

输入规模是n，求和算法的第一种，需要代码运行n次，输入规模使得操作数量是f(n)=n,第二种无论n为
多少，运行次数都为1，即f(n)=1。随着n值的越来越大，他们在时间上的差异就越来越大。

#### 2.3 函数的渐近增长

假设两个算法的输入规模都是n，算法A要做2n+3次操作，算法B要做3n+1次操作，谁才是更好的算法呢？准确的
说，答案是不一定的（如下图）。
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9.jpg)
当n=1时，算法A效率不如B，当n=2时，两个效率相同。当n>2时，算法A就优于算法B了，随着n的增加，算法A比
算法B越来越好了（执行的次数明显比B少），于是得出结论，A总体上要好过B。

函数的渐近增长：给定两个函数f(n)和g(n),如果存在一个整数N（上述的2即是这种情况），使得对于所有的n>N，f(n)总是比g(n)大，那么，
我们说f(n)的增长渐近快于g(n)。

随着n的增大，后面的+3还是+1其实并不影响最终的算法变化，例如算法A'与算法B',所以，我们可以忽略这些加法的常数。

`下面的例子`
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_10.jpg)
当n小于等于3时，算法C要差于算法D,但当n>3时后，算法C的优势就越来越优于算法D了，而当后面的常数去掉后，结果并没有什么改变，甚至
去掉与n相乘的常数，这样的结果也没发生改变。也就是说，`与最高次项相乘的常数并不重要。最高次项的指数大的，函数随着n的增长，结果
也会变得增长特别快。`

`最后一个例子`
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_11.jpg)
当n的值越来越大时，3n+1已经没法和2*n^2的结果相比较，最终几乎可以忽略不计。也就是说，随着n值变得非常大之后，算法G其实已经趋近于算法
I。于是可以得到这样一个结论，判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。  
判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的。根据刚才的几个例子，可以对比这几个算法函数的渐近增长性，基本可以分析出
：某个算法，随着n的增大，他会越来越优于另一种算法，或者越来越差于另一种算法。这其实就是事前估算方法的理论依据，通过算法时间复杂度来估算
算法时间效率。

#### 2.4 算法时间复杂度

定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，今儿分析T(n)随着n的变化情况并确定T(n)的数量级。算法的时间复杂度，
也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的时间复杂度，简称
为时间复杂度。其中f(n)是问题规模n的某个函数。

这样用大写O()来体现算法时间复杂度的记法，称之为大O记法。一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。显然，计算1+2+...+100的A
算法与B算法的时间复杂度分别为O(n),O(1)。非官方的叫法，O(1)叫常数阶，O(n)叫线性阶、[(下方公式由在线LaTeX编辑器编辑)](https://www.codecogs.com/latex/eqneditor.php)<img src="https://latex.codecogs.com/png.latex?$&space;O(n^2)&space;$" title="$ O(n^2) $" />叫平方阶，当然，还有其他的一些阶。

##### 2.4.1 推导大O阶方法

>如何分析一个算法的时间复杂度呢？即如何推导大O阶呢？下面的推导方法基本上就是总结前面的例子。

```
推导大O阶：
1.用常数1取代运行实践中的所有加法常数。
2.在修改后的运行次数函数中，只保留最高阶项。
3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。
得到的结果就是大O阶。
```

感觉已经得到了一个推导算法时间复杂度的万能公式。可事实上，分析一个算法的时间复杂度，没有这么简单，还需要多看几个例子。

##### 2.4.2 常数阶

首先顺序结构的时间复杂度。下面这个算法，也就是刚才的第二种算法（高斯算法），为什么时间复杂度不是O(3),而是O(1)。
{% highlight java %}
int sum = 0,n = 100;//执行一次
sum = (1 + n)*n/2;//执行一次
System.out.println(sum);//执行一次
{% endhighlight %}
这个算法的运行次数函数是f(n)=3。根据我们推导大O阶的方法，第一步就是把常数3改为1。在保留最高阶项时发现，它根本没有最高阶项，
所以这个算法的时间复杂度为O(1)。  
另外，试想一下，如果这个算法当中的语句 sum=(1+n)*n/2有10句，即
{% highlight java %}
int sum = 0,n = 100;//执行一次
sum = (1 + n)*n/2;//执行第1次
sum = (1 + n)*n/2;//执行第2次
sum = (1 + n)*n/2;//执行第3次
sum = (1 + n)*n/2;//执行第4次
sum = (1 + n)*n/2;//执行第5次
sum = (1 + n)*n/2;//执行第6次
sum = (1 + n)*n/2;//执行第7次
sum = (1 + n)*n/2;//执行第8次
sum = (1 + n)*n/2;//执行第9次
sum = (1 + n)*n/2;//执行第10次
System.out.println(sum);//执行一次
{% endhighlight %}
事实上无论n为多少，上面的两段代码就是3次和12次执行的差异。这种与问题规模的大小无关（n的多少），执行时间恒定的算法，
我们称之为具有O(1)的时间复杂度，又叫常数阶。  
`注意：不管这个常数是多少，都记作O(1)，而不是 O(3),O(12)等其他任何数字。`

对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着n的变大而发生变化，所以单纯的分支结构（不包含在循环结构中），
其时间复杂度也是O(1)。

##### 2.4.3 线性阶

线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行的次数。因此，我们要分析算法的
复杂度，关键就是要分析循环结构的运行情况。  
下面这段代码，它的循环的时间复杂度为O(n),因为循环体中的代码需要执行n次。
{% highlight java %}
int i;
for(int i = 0;i < n;i++){
	//时间复杂度为O(1)的程序步骤序列
}
{% endhighlight %}

##### 2.4.4 对数阶

{% highlight java %}
int count = 1;
while(count < n){
	count = count * 2;
}
{% endhighlight %}
由于每次count乘以2之后，就距离n更近了一分。也就是说，有多少个2相乘后大于n，则会退出循环。由[(下方公式由在线LaTeX编辑器编辑)](https://www.codecogs.com/latex/eqneditor.php)![](https://latex.codecogs.com/png.latex?$&space;2^X=n&space;$),得到[(下方公式由在线LaTeX编辑器编辑)](https://www.codecogs.com/latex/eqneditor.php)![](https://latex.codecogs.com/png.latex?$x=log_2&space;n&space;$)。所以这个
循环的时间复杂度为[(下方公式由在线LaTeX编辑器编辑)](https://www.codecogs.com/latex/eqneditor.php)![](https://latex.codecogs.com/png.latex?$O(log_2&space;n)&space;$)。

##### 2.4.3 平方阶

下面例子是一个循环嵌套，他的内循环刚才我们已经分析过，时间复杂度为O(n)。
{% highlight java %}
int i,j;
for(int i = 0;i < n;i++){
	for(int j = 0;j < n;j++){
		//时间复杂度为O(1)的程序步骤序列
	}
}
{% endhighlight %}
而对于外层的循环，不过是内部这个时间复杂度为O(n)的语句，再循环n次，所以这段代码的时间复杂度为[(下方公式由在线LaTeX编辑器编辑)](https://www.codecogs.com/latex/eqneditor.php)<img src="https://latex.codecogs.com/png.latex?$&space;O(n^2)&space;$" title="$ O(n^2) $" />。
如果外循环的循环次数改为了m,时间复杂度就变为O(m*n)。所以可以得出结论，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。  
那么下面这个循环嵌套，它的时间复杂度是多少呢？

{% highlight java %}
int i,j;
for(i = 0;i < n;i++){
	for(j = i;j < n;j++){
		//时间复杂度为O(1)的程序步骤序列
	}
}
{% endhighlight %}
由于当i=0时，内循环执行了n次，当i=1时，执行了n-1次，当i=n-1时，执行了1次。所以总的执行次数为：
！[](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F_1.jpg)
用我们推导大O阶的方法，第一条，没有加法常数不予考虑；第二条，只保留最高阶项，因此保留n^2/2;第三条，去除这个项相乘的常数，也就是去除1/2,
最终这段代码的时间复杂度为[(下方公式由在线LaTeX编辑器编辑)](https://www.codecogs.com/latex/eqneditor.php)<img src="https://latex.codecogs.com/png.latex?$&space;O(n^2)&space;$" title="$ O(n^2) $" />。
继续看例子，对于方法调用的时间复杂度又如何拆分。

{% highlight java %}
int i,j;
for(i = 0;i < n;i++){
	function(i);
}

void function(int count){
	System.out.println(count);
}
{% endhighlight %}

function的时间复杂度是O(1),所以整体的时间复杂度是O(n)。

##### 2.4.4 常见的时间复杂度

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F_2.jpg)

##### 2.4.5 最坏情况与平均情况

你早晨出门上班后突然想起，手机忘带了，于是回家找，打开门一看，手机在茶几上躺着。这还好，基本没花什么时间寻找。可如果不是放在
那里，你就得进去到处找，找完客厅找卧室、找完卧室找厨房，就是找不到，时间一分一秒的过去，你突然想起来，可以用家里座机打一下手
机，听着铃声的方向，终于找到了，原来在枕头下面。你再去上班，迟到。这一年的全勤奖，就因为这没了。  
找东西有运气好的时候，也有怎么也找不到的情况。但在现实中，通常我们碰到的绝大多数既不是最好的也不是最坏的，所以算下来是平均
情况居多。  
算法的分析也是类似，我们查找一个有n个随即数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度是O(1)，但也
有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是O(n)，这是最坏的一种情况了。  
`最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间
都是最坏情况的运行时间。`  
而平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。也就是说，我们运行一段程序代码时，是希望看到平均运行时间的。可现
实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。  
对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂
度，这种方法称为最坏时间复杂度。`一般在没有特殊说明的情况下，都是指最坏时间复杂度。`

#### 2.5 算法空间复杂度

我们在写代码时，完全可以用空间来换取时间，比如说，要判断某某年是不是闰年，你可能会花一点心思写了一个算法，而且由于是一个算法，
也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。还有另一个办法就是，事先建立一个有2050个元素的数组（年数略比现
实多一点），然后把所有的年份按下标的数字对应，如果是闰年，次数组项的值就是1，如果不是值为0。这样，所谓的判断某一年是否是闰年，
就变成了查找这个数组的某一项的值是多少的问题。此时，我们的运算是最小化了，但是硬盘上或者内存中需要存储这2050个0和1。  
这是通过一笔空间上的开销来换取计算时间的小技巧，到底哪一个好，其实要看你用在什么地方。  
`算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句
关于n所占存储空间的函数。`  
一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入
数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间对于输入
数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。  
通常，我们都使用`时间复杂度`来指运行时间的需求，使用`空间复杂度`指空间需求。当不用限定词的使用`复杂度`时，通常是指时间复杂度。

#### 2.6 总结

数据结构与算法的关系是相互依赖不可分割的。  
算法的定义：算法是解决待定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。  
算法的特性：有穷性、确定性、可行性、输入、输出。  
算法设计要求：正确定、可读性、健壮性、高效率和低存储量需求。  
算法特性与算法设计容易混淆，需要对比记忆。  
算法的度量方法：事后统计方法（不科学、不准确）、事前分析估算方法。  
在讲解如何用事前分析估算方法之前，我们先给出了函数渐近增长的定义。  
函数的渐进增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于
g(n)。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，如果我们可以对比算法的关键执行
次数（函数的渐进增长性），基本就可以分析出：某个算法，随着n的变大，它会越来越优于另一种算法，或者越来越差于另一个算法。然后
给出了算法时间复杂度的定义和推导大O阶的步骤。  
推导大O阶：  
+ 用常数1取代运行时间中的所有加法常数。  
+ 在修改后的运行次数函数中，只保留最高阶项。  
+ 如果最高阶项存在且不是1，则去除与这个项相乘的常数  
得到的结果就是大O阶。  
通过这个步骤，我们可以在得到算法的运行次数表达式后，很快得到它的时间复杂度，即大O阶。接着给出常见时间复杂度所耗时间的大小排列，
最后给出了关于算法最坏情况和平均情况的概念，以及空间复杂度的概念。
通过这个步骤，我们可以在得到算法的运行次数表达式后，很快得到它的时间复杂度，即大O阶。

### 3、线性表

幼儿园放学的例子：幼儿园放学的时候，老师总是带着小朋友们，一个拉着另一个的衣服，一次从教室出来，小明排在第5个，每次他都是第5个，
前面同样是那个小女孩，后面一直是那个小男孩。老师说，这样做是为了保障小朋友的安全，避免漏掉小朋友，所以给他们安排了出门的次序，
事先规定好了，谁在谁的前面，谁在谁的后面。这样养成习惯后，如果有谁没有到位，他前面或者后面的小朋友就会主动报告老师，某人不在。
这种排好队的组织方式，就是下面所要介绍的数据结构：线性表。

#### 3.1线性表的定义

线性表，从字面理解，是具有像线一样性质的表。上面提到的一个班级小朋友，一个跟着一个排队，如同有一根线把他们串联起来，就可以称之为
线性表。
**线性表（List）：零个或多个相同类型的数据元素的有限序列。**
首先强调它是一个序列。也就是说，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个
前驱和后继。  
然后，线性表强调是有限的，事实上，在计算机中处理的对象都是有限的，那种无限的数列，只存在与数学的概念中。  
若将线性表记作：a1,a2,...,a(i-1),ai,a(i+1),...,an。则线性表元素的个数是n(n大于等于0)定义为线性表的长度，当n=0时，称之为空表。  
班级同学的点名册，是不是线性表？是，它是有限序列，也满足类型相同的特点。这个点名册中，每一个元素除学生的学号外，还可以有同学的姓名
、性别、出生年月什么的，这其实就是前面讲的数据项。`在较复杂的线性表中，一个数据元素可以由若干个数据项组成。`  
一群同学排队买演唱会门票，每人限购一张，此时排队的人群是不是线性表？是。此时，来了三个同学要插当中一个同学A的队，说同学A手里拿着
的三个书包就是用来占位的，书包也算是在排队。如果你是后面早已来排队的同学，你们愿不愿意？肯定不愿意，书包怎么能算排队的人呢，
如果这也算，每个人浑身上下的衣服都在排队了。于是不让这三个人插队。这里用线性表的定义来解释：因为要相同类型的数据，
书包根本不算事人，当然排队无效。

#### 3.2线性表的物理结构

**线性表的物理存储结构有两种：顺序存储结构、链式存储结构。**

##### 3.2.1 顺序存储结构

**1.顺序存储定义**
`顺序存储结构：用一段地址连续的存储单元依次存储线性表的数据元素。`  

**2.顺序存储方式**  
线性表的顺序存储结构，说白了，就是在内存中找了块地儿，通过占位的形式，把一定内存空间给占了，然后把相同数据类型的
数据元素依次存放在这块空地中。既然线性表的每个数据元素的类型都相同，所以可以用`Java一维数组来实现顺序存储结构`，即把第一个
数据元素存到数组下标为0的位置中，接着把线性表相邻的元素存储在数组中相邻的位置。

{% highlight java %}
public static void main(String[] args){
	
	//数组,开辟了大小为20的连续存储空间
	String[] strArr = new String[20];
	//线性表的长度
	int length = 0;
	strArr[0]="1";
	strArr[1]="2";
	for(int i = 0;i < strArr.length;i++){
		if(strArr[i]!=null){
			length++;
		}
	}
	System.out.println(length);
	System.out.println(strArr.length);
}
{% endhighlight %} 
数组的长度和线性表的长度需要区分一下，数组的长度是存放线性表的存储空间的长度，数组长度一般是不变的。但是也有可变数组，如ArrayList。  
在任意时刻，线性表的长度都应该小于等于数组的长度。

**3.地址计算方法** 

`存储器中的每个存储单元都有自己的编号，这个编号称为地址。`  
假设每个数据元素占用c个存储单元，那么线性表中第i个数据元素ai的存储位置可以由a1推算得出（LOC表示获得存储位置的函数）：  
LOC(ai)=LOC(a1)+(i-1)*c  
通过这个公式，可以推算出线性表中任意位置的地址，所用时间都是相同的。对线性表每个位置的存入或者取出数据，对于计算机来说
都是相等的时间，也就是一个常数，因此用我们算法中学到的时间复杂度概念来说，它的存取时间性能为O(1)。通常把具有这一特点
的存储结构称为随即存储结构。

**4.插入操作** 

对于线性表任意位置的存取，它的时间复杂度为O(1),如果要在线性表的第i个位置插入新元素e,该如何操作？  

>举个例子，本来我们在春运时去买火车票，大家都排队排的好好的。这时来了一个美女，对着队伍中排在第三的你说，“大哥，求求你帮帮忙，我家
母亲有病，我得急着回去看她，能不能让我排在你的前面？”你心一软，就同意了。这时，你必须得后退一步，否则她是没法进入到队伍来的。这可不得了，
后面的人像蠕虫一样，全部都得后退一步。骂声四起。  

这个例子其实已经说明了线性表的顺序存储结构，在插入数据时的实现过程（如下图）  
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_12.jpg)  
插入算法的思路：
+ 如果插入位置不合理，抛出异常；  
+ 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；  
+ 从最后一个元素开始向前遍历到第i个位置，分别将他们都向后移动一个位置； 
+ 将要插入元素填入位置i处； 
+ 表长+1。

`代码实现`
{% highlight java %}
public static void insert(int i, String str,String[] strArr) throws Exception {  
    	 
	//线性表的长度
	int length = 0;
	for(int m = 0;m < strArr.length;m++){
		if(strArr[m]!=null){
			length++;
		}
	}
	//数组长度
	int maxSize = strArr.length;
	if(length==maxSize){  
		throw new Exception("位置已满,别插了");  
	}  
	//如果你插入的位置比0小,或者你插入的位置比现在最大长度还大  
	if(i<0||i>maxSize-1){  
		throw new Exception("参数有错误");  
	}  
	for(int k=length-1;k>=i;k--){  
		strArr[k+1]=strArr[k];  
	}
	//将数据元素插入数组中
	strArr[i] = str; 
	//表长加1
	length++;
	String temp = "";
	for(int n=0;n<strArr.length;n++){
		if(strArr[n]!=null){
			if(("").equals(temp)){
				temp = strArr[n];
			}else{
				temp += ","+strArr[n];
			}
		}
	}
	//线性表里的数据元素及表长
	System.out.println(temp+":"+length);   
}  
    
public static void main(String[] args){
	//数组
	String[] strArr = new String[20];
	strArr[0]="1";
	strArr[1]="2";
	strArr[2]="3";
	strArr[3]="4";
	strArr[4]="5";
	strArr[5]="6";
	strArr[6]="7";
	try {
		//在位置为2,插入30这个数据元素
		insert(2,"30",strArr);
	} catch (Exception e) {
		e.printStackTrace();
	}
	  
}
{% endhighlight %}

**5.删除操作**

>接着刚才的例子。此时后面排队的人群意见很大，都说怎么可以这样，不管什么原因，插队就是不行，有本事，找火车站开后门去。
就在这时，远处跑来一个胖子，对着美女喊，可找到你了，你这骗子，还我钱。只见这女的二话不说，突然就冲出了队伍，胖子追在
其后，消失在人群中。于是排队的人群，又像蠕虫一样，均向前移动了一步。  

这就是线性表的顺序存储结构删除元素的过程（如下图）  
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_13.jpg)  
删除算法的思路：
+  如果删除位置不合理，抛出异常；
+ 取出删除元素；
+ 从删除元素位置开始到最后一个元素位置，分别将它们都向前移动一个位置。
+ 表长减1。  

`代码实现`
{% highlight java %}
public static void main(String[] args){
	//数组
	String[] strArr = new String[7];
	strArr[0]="1";
	strArr[1]="2";
	strArr[2]="3";
	strArr[3]="4";
	strArr[4]="5";
	strArr[5]="6";
	strArr[6]="7";
	try {
		//删除位置为0的数据元素
		delete(0,strArr);
	}catch (Exception e) {
		e.printStackTrace();
	}
	  
}

public static void delete(int i,String[] strArr) throws Exception {  
	 
	//线性表的长度
	int length = 0;
	for(int m = 0;m < strArr.length;m++){
		if(strArr[m]!=null){
			length++;
		}
	}
	
	//删除线性表第i各位置的元素  
	if(length == 0){  
		throw new Exception("该表空,无法删除");  
	}  
	if(i<0||i>length-1){  
		throw new Exception("该表删除的位置越界,无法删除");  
	}  
	for(int k=i;k<=length-1;k++){  
		//越界的处理
		if(k+1>length-1){
			strArr[k]=null;
		}else{
			strArr[k]=strArr[k+1]; 
		}
		 
	}  
	//表长减1
	length--;  
	
	String temp = "";
	for(int n=0;n<strArr.length;n++){
		if(strArr[n]!=null){
			if(("").equals(temp)){
				temp = strArr[n];
			}else{
				temp += ","+strArr[n];
			}
		}
	}
	//线性表里的数据元素及表长
	System.out.println(temp+":"+length);  
}
{% endhighlight %}
现在我们来分析一下，插入和删除的时间复杂度。  
先来看最好的情况，如果元素要插入到最后一个位置，或者删除最后一个元素，此时时间复杂度为O(1),因为
不需要移动其他元素。  
最坏的情况，如果元素要插入到第一个位置或者删除第一个元素，那就意味着要移动所有的元素向后或者向前，
所以这个时间复杂度为O(n)。  
至于平均的情况，由于元素插入到第i个位置，或删除第i个元素，需要移动n-i个元素，根据概率原理，每个位置
插入或删除元素的可能性是相同的，也就是说位置靠前，移动元素多，位置靠后，移动元素少。最终平均移动次数
和最中间的那个元素的移动次数相等，为（n-1）/2。根据前面时间复杂度的推导，可以得出，平均时间复杂度还
是O(n)。  
这说明线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O(1),而插入或删除时，时间复杂
度都是O(n)。这就说明，它比较适合元素个数不太变化，而更多的是存取数据的应用。当然，它的优缺点还不止这些...  

**6.线性表顺序存储结构的优缺点**
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_14.jpg)
所谓的“碎片”，就是由于顺序存储结构申请空间时会大块（连续的空间）的申请，导致内存切割不均匀，这样就会有许多
被切剩下的小块空间，这些小块空间不容易被存储结构调用，就造成了浪费。

##### 3.2.2 链式存储结构

**1.顺序存储结构不足的解决办法**

线性表的顺序存储结构是有缺点的，最大的缺点就是插入和删除时需要移动大量元素，这显然就需要耗费时间。  
要解决这个问题，我们就得考虑一下导致这个问题的原因。  
为什么当插入和删除时，需要移动大量元素，仔细分析后，发现原因就在于相邻两个元素的存储位置也具有邻居关系。
他们编号是1,2,3，...，n,它们在内存中的位置也是挨着的，中间没有空隙，当然就无法快速的插入，而删除后，当中就会
留出空隙，自然需要弥补。问题就出现在这里。  
+ A同学思路：让当中每个元素之间都留有一个空位置，这样要插入时，就不至于移动。可一个空位置如何解决多个相同位置
插入数据的问题呢？所以这个想法显然不行。
+ B同学思路：那就让当中每个元素之间都留有足够多的位置，根据实际情况制定空隙大小，不如10个，这样插入时，就不需要移动
了。万一10个空位用完了，再考虑移动使得每个位置之间都有10个空位置。如果删除，就直接删掉，把位置留空即可。这样似乎
暂时解决了插入和删除的移动数据问题。可这对于超过10个同位置数据的插入，效率上还是存在问题。对于数据的遍历，也会以为空
位置太多而造成判断时间上的浪费。而且显然这里空间复杂度还增加了，因为每个元素之间都有若干个空位置。
+ C同学思路：我们反正也是要让相邻元素间留有足够余地，那干脆所有的元素都不要考虑相邻位置了，哪有空位就到哪里，只需要让
每个元素知道它下一个元素的位置在哪里，这样，我们在第一个元素时，就知道第二个元素的位置（内存地址），而找到它。这样
所有的元素我们就可以通过遍历而找到。  
好！太棒了，这个想法非常好！

**1.链式存储结果定义**

在以前顺序存储结构中，每个数据元素只需要存数据元素信息就可以了。线在链式结构中，除了要存数据元素信息外，还需要存储它的后继元素
的存储地址。  
因此，为了表示每个数据元素ai与其直接后继数据元素a(i+1)之间的逻辑关系，对数据ai来说，除了存储其本身的信息之外，还需存储一个指示
其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的
信息称作指针或链。这两部分信息组成数据元素ai的存储映像，称为结点（Node）。  
n个结点



 




















