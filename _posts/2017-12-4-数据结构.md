---
layout:     post
title:      数据结构
subtitle:   笔记
date:       2017-12-4
author:     赵小恒
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - 数据结构
---

### 1、基本概念和术语

#### 1.1 数据

数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机
处理的符号集合。数据不仅仅包括整型，实型等数值类型，还包括字符、声音、图像、视频等非数值类型。

#### 1.2 数据元素

数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。在人类
中，什么是数据元素？当然是人了。畜类呢？诸如牛、马、羊等动物就是畜类的数据元素。

#### 1.3 数据项

数据项：一个数据元素可以由若干个数据项组成。比如人这样的数据元素，可以有眼、耳、鼻、手等这些数据项，
也可以有姓名、年龄、性别等数据项，具体有哪些数据项，要视你做的系统来决定。`数据项是数据不可分割的最小单位`。
真正讨论问题时，数据元素才是数据结构中建立数据模型的重点。就像我们讨论一部电影时，是讨论电影角色这样的“数据元素”，
而不是这对这个角色的姓名或者年龄这样的“数据项”去研究分析。

#### 1.4 数据对象

数据对象：是性质相同的数据元素的集合，是数据的子集。什么叫性质相同呢，是指数据元素具有相同数量和类型的数据项，比如，人
都有姓名、生日、性别等相同的数据项。  
既然数据对象是数据的子集，在实际应用中，处理的数据元素通常具有相同性质，在不产生混淆的情况下，我们都将数据对象简称为数据。

#### 1.5 数据结构

数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的
数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。

#### 1.6 逻辑结构与物理结构

>按照视点的不同，我们把数据结构分为逻辑结构和物理结构

##### 1.6.1 逻辑结构

定义：是指数据对象中数据元素之间的相互关系。这也是我们今后需要关心的问题。逻辑结构共分为四种：

**1.集合结构**

定义：集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。各个元素是平等的（如下图）。

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_1.jpg)

**2.线性结构**

定义：线性结构中的数据元素之间是一对一的关系（如下图）。

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_2.jpg)

**3.树形解构**

定义：树形解构中的数据元素之间存在一种一对多的层次关系（如下图）。

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_3.jpg)

**4.图形结构**

定义：图形结构的元素是多对多的关系（如下图）。

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_4.jpg)

##### 1.6.2 物理结构

定义：是指数据的逻辑结构在计算机中的存储形式。也称存储结构。实际上就是如何把数据元素存储到计算机的存储器中。
存储器主要针对内存，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。数据元素的存储结构有两种：
顺序存储于链式存储。

**1. 顺序存储结构**

定义:是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。

这种存储结构其实很简单，就是排队占位。大家都按顺序排好，每个人占一小段空间，大家谁也别插谁的队。数组就是这样的，
顺序存储结构(如下图)。

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5.jpg)

**2.链式存储结构**

如果就是这么简单和有规律，一切就好办了。可实际上，总会有人插队，也会有人要上厕所、有人会放弃排队。所以这个队伍当中
会添加新成员，也有可能会去掉老元素，整个结构时刻都处于变化中。显然，面对这样时常要变化的结构，顺序存储是不科学的，那怎么办呢？
这就需要链式存储了。

定义：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此
需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置（如下图）

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6.jpg)

显然，链式存储就灵活多了，数据存在哪里不重要，只要有一个指针存放了相应的地址就能找到它了。

现在如医院、银行等地方，设置了排队系统，也就是每个人先领一个号，等着叫号，叫到时去办理业务或看病。在等待的时候，你爱在哪都可以。你关注的
是前一个号有没有被叫到，叫到了，下一个就轮到了。

#### 1.7 抽象数据类型
##### 1.7.1 数据类型

数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

##### 1.7.2 抽象数据类型

抽象数据类型：是指一个数学模型及定义在该模型上的一组操作。

#### 1.8 总结

数据结构相关概念（如下图）

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7.jpg)

数据结构分为逻辑结构与物理结构（也叫存储结构）（如下图）

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_8.jpg)

### 2、算法

定义：普遍认可的算法定义是：解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，
并且每条指令表示一个或多个操作。

#### 2.1 算法的特性

+ 输入输出：算法具有零个或多个输，至少有一个或多个输出。入打印“hello,world!”,这样的代码不需要任何参数，若
没输出，你用这个算法干嘛？输出的形式可以是打印输出，也可以是返回值形式等。

+ 有穷性：指算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。

+ 确定性：算法的每一步骤都具有确定的含义，不会出现二义性。

+ 可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

#### 2.2 算法设计的要求

+ 证确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。

+ 可读性：算法设计的另一目的是为了便于阅读、理解和交流。

+ 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。
+ 时间效率高和存储量低。

#### 2.3 算法效率的度量方法

+ 事后统计方法：这种方法主要是通过设计好的程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法
效率的高低。

+ 事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。

下面实际例子分析

问题描述：`求和1+2+...+100`

**1.第一种算法**
{% highlight java %}
int i,sum=0,n=100;//执行1次
for(int i=1;i<n;i++){//执行n+1次
	sum = sum + i;//执行n次
}
System.out.println(sum);//执行1次
{% endhighlight %}

**2.第二种算法**

{% highlight java %}
int sum=0,n=100;//执行1次
sum = (1 + n) * n / 2;//执行1次
System.out.println(sum);//执行1次
{% endhighlight %}

结论：第一种算法执行了1+（n+1）+n+1=2n+3次；而第二种算法是3次，去掉收尾语句及第一个算法的
判断次数的开销，我们关注的代码就是中间的部分，也就是n次与1次的差距，算法好坏显而易见。

输入规模是n，求和算法的第一种，需要代码运行n次，输入规模使得操作数量是f(n)=n,第二种无论n为
多少，运行次数都为1，即f(n)=1。随着n值的越来越大，他们在时间上的差异就越来越大。

#### 2.3 函数的渐近增长

假设两个算法的输入规模都是n，算法A要做2n+3次操作，算法B要做3n+1次操作，谁才是更好的算法呢？准确的
说，答案是不一定的（如下图）。
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9.jpg)
当n=1时，算法A效率不如B，当n=2时，两个效率相同。当n>2时，算法A就优于算法B了，随着n的增加，算法A比
算法B越来越好了（执行的次数明显比B少），于是得出结论，A总体上要好过B。

函数的渐近增长：给定两个函数f(n)和g(n),如果存在一个整数N（上述的2即是这种情况），使得对于所有的n>N，f(n)总是比g(n)大，那么，
我们说f(n)的增长渐近快于g(n)。

随着n的增大，后面的+3还是+1其实并不影响最终的算法变化，例如算法A'与算法B',所以，我们可以忽略这些加法的常数。

`下面的例子`
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_10.jpg)
当n小于等于3时，算法C要差于算法D,但当n>3时后，算法C的优势就越来越优于算法D了，而当后面的常数去掉后，结果并没有什么改变，甚至
去掉与n相乘的常数，这样的结果也没发生改变。也就是说，`与最高次项相乘的常数并不重要。最高次项的指数大的，函数随着n的增长，结果
也会变得增长特别快。`

`最后一个例子`
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_11.jpg)
当n的值越来越大时，3n+1已经没法和2*n^2的结果相比较，最终几乎可以忽略不计。也就是说，随着n值变得非常大之后，算法G其实已经趋近于算法
I。于是可以得到这样一个结论，判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。  
判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的。根据刚才的几个例子，可以对比这几个算法函数的渐近增长性，基本可以分析出
：某个算法，随着n的增大，他会越来越优于另一种算法，或者越来越差于另一种算法。这其实就是事前估算方法的理论依据，通过算法时间复杂度来估算
算法时间效率。

#### 2.4 算法时间复杂度

定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，今儿分析T(n)随着n的变化情况并确定T(n)的数量级。算法的时间复杂度，
也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的时间复杂度，简称
为时间复杂度。其中f(n)是问题规模n的某个函数。

这样用大写O()来体现算法时间复杂度的记法，称之为大O记法。一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。显然，计算1+2+...+100的A
算法与B算法的时间复杂度分别为O(n),O(1)。非官方的叫法，O(1)叫常数阶，O(n)叫线性阶、[(下方公式由在线LaTeX编辑器编辑)](https://www.codecogs.com/latex/eqneditor.php)<img src="https://latex.codecogs.com/png.latex?$&space;O(n^2)&space;$" title="$ O(n^2) $" />叫平方阶，当然，还有其他的一些阶。

##### 2.4.1 推导大O阶方法

>如何分析一个算法的时间复杂度呢？即如何推导大O阶呢？下面的推导方法基本上就是总结前面的例子。

```
推导大O阶：
1.用常数1取代运行实践中的所有加法常数。
2.在修改后的运行次数函数中，只保留最高阶项。
3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。
得到的结果就是大O阶。
```

感觉已经得到了一个推导算法时间复杂度的万能公式。可事实上，分析一个算法的时间复杂度，没有这么简单，还需要多看几个例子。

##### 2.4.2 常数阶

首先顺序结构的时间复杂度。下面这个算法，也就是刚才的第二种算法（高斯算法），为什么时间复杂度不是O(3),而是O(1)。
{% highlight java %}
int sum = 0,n = 100;//执行一次
sum = (1 + n)*n/2;//执行一次
System.out.println(sum);//执行一次
{% endhighlight %}
这个算法的运行次数函数是f(n)=3。根据我们推导大O阶的方法，第一步就是把常数3改为1。在保留最高阶项时发现，它根本没有最高阶项，
所以这个算法的时间复杂度为O(1)。  
另外，试想一下，如果这个算法当中的语句 sum=(1+n)*n/2有10句，即
{% highlight java %}
int sum = 0,n = 100;//执行一次
sum = (1 + n)*n/2;//执行第1次
sum = (1 + n)*n/2;//执行第2次
sum = (1 + n)*n/2;//执行第3次
sum = (1 + n)*n/2;//执行第4次
sum = (1 + n)*n/2;//执行第5次
sum = (1 + n)*n/2;//执行第6次
sum = (1 + n)*n/2;//执行第7次
sum = (1 + n)*n/2;//执行第8次
sum = (1 + n)*n/2;//执行第9次
sum = (1 + n)*n/2;//执行第10次
System.out.println(sum);//执行一次
{% endhighlight %}
事实上无论n为多少，上面的两段代码就是3次和12次执行的差异。这种与问题规模的大小无关（n的多少），执行时间恒定的算法，
我们称之为具有O(1)的时间复杂度，又叫常数阶。  
`注意：不管这个常数是多少，都记作O(1)，而不是 O(3),O(12)等其他任何数字。`

对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着n的变大而发生变化，所以单纯的分支结构（不包含在循环结构中），
其时间复杂度也是O(1)。

##### 2.4.3 线性阶

线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行的次数。因此，我们要分析算法的
复杂度，关键就是要分析循环结构的运行情况。  
下面这段代码，它的循环的时间复杂度为O(n),因为循环体中的代码需要执行n次。
{% highlight java %}
int i;
for(int i = 0;i < n;i++){
	//时间复杂度为O(1)的程序步骤序列
}
{% endhighlight %}

##### 2.4.4 对数阶

{% highlight java %}
int count = 1;
while(count < n){
	count = count * 2;
}
{% endhighlight %}
由于每次count乘以2之后，就距离n更近了一分。也就是说，有多少个2相乘后大于n，则会退出循环。由[(下方公式由在线LaTeX编辑器编辑)](https://www.codecogs.com/latex/eqneditor.php)![](https://latex.codecogs.com/png.latex?$&space;2^X=n&space;$),得到[(下方公式由在线LaTeX编辑器编辑)](https://www.codecogs.com/latex/eqneditor.php)![](https://latex.codecogs.com/png.latex?$x=log_2&space;n&space;$)。所以这个
循环的时间复杂度为[(下方公式由在线LaTeX编辑器编辑)](https://www.codecogs.com/latex/eqneditor.php)![](https://latex.codecogs.com/png.latex?$O(log_2&space;n)&space;$)。

##### 2.4.3 平方阶

下面例子是一个循环嵌套，他的内循环刚才我们已经分析过，时间复杂度为O(n)。
{% highlight java %}
int i,j;
for(int i = 0;i < n;i++){
	for(int j = 0;j < n;j++){
		//时间复杂度为O(1)的程序步骤序列
	}
}
{% endhighlight %}
而对于外层的循环，不过是内部这个时间复杂度为O(n)的语句，再循环n次，所以这段代码的时间复杂度为[(下方公式由在线LaTeX编辑器编辑)](https://www.codecogs.com/latex/eqneditor.php)<img src="https://latex.codecogs.com/png.latex?$&space;O(n^2)&space;$" title="$ O(n^2) $" />。
如果外循环的循环次数改为了m,时间复杂度就变为O(m*n)。所以可以得出结论，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。  
那么下面这个循环嵌套，它的时间复杂度是多少呢？

{% highlight java %}
int i,j;
for(i = 0;i < n;i++){
	for(j = i;j < n;j++){
		//时间复杂度为O(1)的程序步骤序列
	}
}
{% endhighlight %}
由于当i=0时，内循环执行了n次，当i=1时，执行了n-1次，当i=n-1时，执行了1次。所以总的执行次数为：
！[](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F_1.jpg)
用我们推导大O阶的方法，第一条，没有加法常数不予考虑；第二条，只保留最高阶项，因此保留n^2/2;第三条，去除这个项相乘的常数，也就是去除1/2,
最终这段代码的时间复杂度为[(下方公式由在线LaTeX编辑器编辑)](https://www.codecogs.com/latex/eqneditor.php)<img src="https://latex.codecogs.com/png.latex?$&space;O(n^2)&space;$" title="$ O(n^2) $" />。
继续看例子，对于方法调用的时间复杂度又如何拆分。

{% highlight java %}
int i,j;
for(i = 0;i < n;i++){
	function(i);
}

void function(int count){
	System.out.println(count);
}
{% endhighlight %}

function的时间复杂度是O(1),所以整体的时间复杂度是O(n)。

##### 2.4.4 常见的时间复杂度

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F_2.jpg)

##### 2.4.5 最坏情况与平均情况

你早晨出门上班后突然想起，手机忘带了，于是回家找，打开门一看，手机在茶几上躺着。这还好，基本没花什么时间寻找。可如果不是放在
那里，你就得进去到处找，找完客厅找卧室、找完卧室找厨房，就是找不到，时间一分一秒的过去，你突然想起来，可以用家里座机打一下手
机，听着铃声的方向，终于找到了，原来在枕头下面。你再去上班，迟到。这一年的全勤奖，就因为这没了。  
找东西有运气好的时候，也有怎么也找不到的情况。但在现实中，通常我们碰到的绝大多数既不是最好的也不是最坏的，所以算下来是平均
情况居多。  
算法的分析也是类似，我们查找一个有n个随即数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度是O(1)，但也
有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是O(n)，这是最坏的一种情况了。  
`最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间
都是最坏情况的运行时间。`  
而平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。也就是说，我们运行一段程序代码时，是希望看到平均运行时间的。可现
实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。  
对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂
度，这种方法称为最坏时间复杂度。`一般在没有特殊说明的情况下，都是指最坏时间复杂度。`

#### 2.5 算法空间复杂度

我们在写代码时，完全可以用空间来换取时间，比如说，要判断某某年是不是闰年，你可能会花一点心思写了一个算法，而且由于是一个算法，
也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。还有另一个办法就是，事先建立一个有2050个元素的数组（年数略比现
实多一点），然后把所有的年份按下标的数字对应，如果是闰年，次数组项的值就是1，如果不是值为0。这样，所谓的判断某一年是否是闰年，
就变成了查找这个数组的某一项的值是多少的问题。此时，我们的运算是最小化了，但是硬盘上或者内存中需要存储这2050个0和1。  
这是通过一笔空间上的开销来换取计算时间的小技巧，到底哪一个好，其实要看你用在什么地方。  
`算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句
关于n所占存储空间的函数。`  
一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入
数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间对于输入
数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。  
通常，我们都使用`时间复杂度`来指运行时间的需求，使用`空间复杂度`指空间需求。当不用限定词的使用`复杂度`时，通常是指时间复杂度。

#### 2.6 总结

数据结构与算法的关系是相互依赖不可分割的。  
算法的定义：算法是解决待定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。  
算法的特性：有穷性、确定性、可行性、输入、输出。  
算法设计要求：正确定、可读性、健壮性、高效率和低存储量需求。  
算法特性与算法设计容易混淆，需要对比记忆。  
算法的度量方法：事后统计方法（不科学、不准确）、事前分析估算方法。  
在讲解如何用事前分析估算方法之前，我们先给出了函数渐近增长的定义。  
函数的渐进增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于
g(n)。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，如果我们可以对比算法的关键执行
次数（函数的渐进增长性），基本就可以分析出：某个算法，随着n的变大，它会越来越优于另一种算法，或者越来越差于另一个算法。然后
给出了算法时间复杂度的定义和推导大O阶的步骤。  
推导大O阶：  
+ 用常数1取代运行时间中的所有加法常数。  
+ 在修改后的运行次数函数中，只保留最高阶项。  
+ 如果最高阶项存在且不是1，则去除与这个项相乘的常数  
得到的结果就是大O阶。  
通过这个步骤，我们可以在得到算法的运行次数表达式后，很快得到它的时间复杂度，即大O阶。接着给出常见时间复杂度所耗时间的大小排列，
最后给出了关于算法最坏情况和平均情况的概念，以及空间复杂度的概念。
通过这个步骤，我们可以在得到算法的运行次数表达式后，很快得到它的时间复杂度，即大O阶。

### 3、线性表

幼儿园放学的例子：幼儿园放学的时候，老师总是带着小朋友们，一个拉着另一个的衣服，一次从教室出来，小明排在第5个，每次他都是第5个，
前面同样是那个小女孩，后面一直是那个小男孩。老师说，这样做是为了保障小朋友的安全，避免漏掉小朋友，所以给他们安排了出门的次序，
事先规定好了，谁在谁的前面，谁在谁的后面。这样养成习惯后，如果有谁没有到位，他前面或者后面的小朋友就会主动报告老师，某人不在。
这种排好队的组织方式，就是下面所要介绍的数据结构：线性表。

#### 3.1线性表的定义

线性表，从字面理解，是具有像线一样性质的表。上面提到的一个班级小朋友，一个跟着一个排队，如同有一根线把他们串联起来，就可以称之为
线性表。
**线性表（List）：零个或多个相同类型的数据元素的有限序列。**
首先强调它是一个序列。也就是说，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个
前驱和后继。  
然后，线性表强调是有限的，事实上，在计算机中处理的对象都是有限的，那种无限的数列，只存在与数学的概念中。  
若将线性表记作：a1,a2,...,a(i-1),ai,a(i+1),...,an。则线性表元素的个数是n(n大于等于0)定义为线性表的长度，当n=0时，称之为空表。  
班级同学的点名册，是不是线性表？是，它是有限序列，也满足类型相同的特点。这个点名册中，每一个元素除学生的学号外，还可以有同学的姓名
、性别、出生年月什么的，这其实就是前面讲的数据项。`在较复杂的线性表中，一个数据元素可以由若干个数据项组成。`  
一群同学排队买演唱会门票，每人限购一张，此时排队的人群是不是线性表？是。此时，来了三个同学要插当中一个同学A的队，说同学A手里拿着
的三个书包就是用来占位的，书包也算是在排队。如果你是后面早已来排队的同学，你们愿不愿意？肯定不愿意，书包怎么能算排队的人呢，
如果这也算，每个人浑身上下的衣服都在排队了。于是不让这三个人插队。这里用线性表的定义来解释：因为要相同类型的数据，
书包根本不算事人，当然排队无效。

#### 3.2线性表的物理结构

**线性表的物理存储结构有两种：顺序存储结构、链式存储结构。**

##### 3.2.1 顺序存储结构

**1.顺序存储定义**
`顺序存储结构：用一段地址连续的存储单元依次存储线性表的数据元素。`  

**2.顺序存储方式**  
线性表的顺序存储结构，说白了，就是在内存中找了块地儿，通过占位的形式，把一定内存空间给占了，然后把相同数据类型的
数据元素依次存放在这块空地中。既然线性表的每个数据元素的类型都相同，所以可以用`Java一维数组来实现顺序存储结构`，即把第一个
数据元素存到数组下标为0的位置中，接着把线性表相邻的元素存储在数组中相邻的位置。

{% highlight java %}
public static void main(String[] args){
	
	//数组,开辟了大小为20的连续存储空间
	String[] strArr = new String[20];
	//线性表的长度
	int length = 0;
	strArr[0]="1";
	strArr[1]="2";
	for(int i = 0;i < strArr.length;i++){
		if(strArr[i]!=null){
			length++;
		}
	}
	System.out.println(length);
	System.out.println(strArr.length);
}
{% endhighlight %} 
数组的长度和线性表的长度需要区分一下，数组的长度是存放线性表的存储空间的长度，数组长度一般是不变的。但是也有可变数组，如ArrayList。  
在任意时刻，线性表的长度都应该小于等于数组的长度。

**3.地址计算方法** 

`存储器中的每个存储单元都有自己的编号，这个编号称为地址。`  
假设每个数据元素占用c个存储单元，那么线性表中第i个数据元素ai的存储位置可以由a1推算得出（LOC表示获得存储位置的函数）：  
LOC(ai)=LOC(a1)+(i-1)*c  
通过这个公式，可以推算出线性表中任意位置的地址，所用时间都是相同的。对线性表每个位置的存入或者取出数据，对于计算机来说
都是相等的时间，也就是一个常数，因此用我们算法中学到的时间复杂度概念来说，它的存取时间性能为O(1)。通常把具有这一特点
的存储结构称为随即存储结构。

**4.插入操作** 

对于线性表任意位置的存取，它的时间复杂度为O(1),如果要在线性表的第i个位置插入新元素e,该如何操作？  

>举个例子，本来我们在春运时去买火车票，大家都排队排的好好的。这时来了一个美女，对着队伍中排在第三的你说，“大哥，求求你帮帮忙，我家
母亲有病，我得急着回去看她，能不能让我排在你的前面？”你心一软，就同意了。这时，你必须得后退一步，否则她是没法进入到队伍来的。这可不得了，
后面的人像蠕虫一样，全部都得后退一步。骂声四起。  

这个例子其实已经说明了线性表的顺序存储结构，在插入数据时的实现过程（如下图）  
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_12.jpg)  
插入算法的思路：
+ 如果插入位置不合理，抛出异常；  
+ 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；  
+ 从最后一个元素开始向前遍历到第i个位置，分别将他们都向后移动一个位置； 
+ 将要插入元素填入位置i处； 
+ 表长+1。

`代码实现`
{% highlight java %}
public static void insert(int i, String str,String[] strArr) throws Exception {  
    	 
	//线性表的长度
	int length = 0;
	for(int m = 0;m < strArr.length;m++){
		if(strArr[m]!=null){
			length++;
		}
	}
	//数组长度
	int maxSize = strArr.length;
	if(length==maxSize){  
		throw new Exception("位置已满,别插了");  
	}  
	//如果你插入的位置比0小,或者你插入的位置比现在最大长度还大  
	if(i<0||i>maxSize-1){  
		throw new Exception("参数有错误");  
	}  
	for(int k=length-1;k>=i;k--){  
		strArr[k+1]=strArr[k];  
	}
	//将数据元素插入数组中
	strArr[i] = str; 
	//表长加1
	length++;
	String temp = "";
	for(int n=0;n<strArr.length;n++){
		if(strArr[n]!=null){
			if(("").equals(temp)){
				temp = strArr[n];
			}else{
				temp += ","+strArr[n];
			}
		}
	}
	//线性表里的数据元素及表长
	System.out.println(temp+":"+length);   
}  
    
public static void main(String[] args){
	//数组
	String[] strArr = new String[20];
	strArr[0]="1";
	strArr[1]="2";
	strArr[2]="3";
	strArr[3]="4";
	strArr[4]="5";
	strArr[5]="6";
	strArr[6]="7";
	try {
		//在位置为2,插入30这个数据元素
		insert(2,"30",strArr);
	} catch (Exception e) {
		e.printStackTrace();
	}
	  
}
{% endhighlight %}

**5.删除操作**

>接着刚才的例子。此时后面排队的人群意见很大，都说怎么可以这样，不管什么原因，插队就是不行，有本事，找火车站开后门去。
就在这时，远处跑来一个胖子，对着美女喊，可找到你了，你这骗子，还我钱。只见这女的二话不说，突然就冲出了队伍，胖子追在
其后，消失在人群中。于是排队的人群，又像蠕虫一样，均向前移动了一步。  

这就是线性表的顺序存储结构删除元素的过程（如下图）  
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_13.jpg)  
删除算法的思路：
+  如果删除位置不合理，抛出异常；
+ 取出删除元素；
+ 从删除元素位置开始到最后一个元素位置，分别将它们都向前移动一个位置。
+ 表长减1。  

`代码实现`
{% highlight java %}
public static void main(String[] args){
	//数组
	String[] strArr = new String[7];
	strArr[0]="1";
	strArr[1]="2";
	strArr[2]="3";
	strArr[3]="4";
	strArr[4]="5";
	strArr[5]="6";
	strArr[6]="7";
	try {
		//删除位置为0的数据元素
		delete(0,strArr);
	}catch (Exception e) {
		e.printStackTrace();
	}
	  
}

public static void delete(int i,String[] strArr) throws Exception {  
	 
	//线性表的长度
	int length = 0;
	for(int m = 0;m < strArr.length;m++){
		if(strArr[m]!=null){
			length++;
		}
	}
	
	//删除线性表第i各位置的元素  
	if(length == 0){  
		throw new Exception("该表空,无法删除");  
	}  
	if(i<0||i>length-1){  
		throw new Exception("该表删除的位置越界,无法删除");  
	}  
	for(int k=i;k<=length-1;k++){  
		//越界的处理
		if(k+1>length-1){
			strArr[k]=null;
		}else{
			strArr[k]=strArr[k+1]; 
		}
		 
	}  
	//表长减1
	length--;  
	
	String temp = "";
	for(int n=0;n<strArr.length;n++){
		if(strArr[n]!=null){
			if(("").equals(temp)){
				temp = strArr[n];
			}else{
				temp += ","+strArr[n];
			}
		}
	}
	//线性表里的数据元素及表长
	System.out.println(temp+":"+length);  
}
{% endhighlight %}
现在我们来分析一下，插入和删除的时间复杂度。  
先来看最好的情况，如果元素要插入到最后一个位置，或者删除最后一个元素，此时时间复杂度为O(1),因为
不需要移动其他元素。  
最坏的情况，如果元素要插入到第一个位置或者删除第一个元素，那就意味着要移动所有的元素向后或者向前，
所以这个时间复杂度为O(n)。  
至于平均的情况，由于元素插入到第i个位置，或删除第i个元素，需要移动n-i个元素，根据概率原理，每个位置
插入或删除元素的可能性是相同的，也就是说位置靠前，移动元素多，位置靠后，移动元素少。最终平均移动次数
和最中间的那个元素的移动次数相等，为（n-1）/2。根据前面时间复杂度的推导，可以得出，平均时间复杂度还
是O(n)。  
这说明线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O(1),而插入或删除时，时间复杂
度都是O(n)。这就说明，它比较适合元素个数不太变化，而更多的是存取数据的应用。当然，它的优缺点还不止这些...  

**6.线性表顺序存储结构的优缺点**
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_14.jpg)
所谓的“碎片”，就是由于顺序存储结构申请空间时会大块（连续的空间）的申请，导致内存切割不均匀，这样就会有许多
被切剩下的小块空间，这些小块空间不容易被存储结构调用，就造成了浪费。

##### 3.2.2 链式存储结构

**1.顺序存储结构不足的解决办法**

线性表的顺序存储结构是有缺点的，最大的缺点就是插入和删除时需要移动大量元素，这显然就需要耗费时间。  
要解决这个问题，我们就得考虑一下导致这个问题的原因。  
为什么当插入和删除时，需要移动大量元素，仔细分析后，发现原因就在于相邻两个元素的存储位置也具有邻居关系。
他们编号是1,2,3，...，n,它们在内存中的位置也是挨着的，中间没有空隙，当然就无法快速的插入，而删除后，当中就会
留出空隙，自然需要弥补。问题就出现在这里。  
+ A同学思路：让当中每个元素之间都留有一个空位置，这样要插入时，就不至于移动。可一个空位置如何解决多个相同位置
插入数据的问题呢？所以这个想法显然不行。
+ B同学思路：那就让当中每个元素之间都留有足够多的位置，根据实际情况制定空隙大小，不如10个，这样插入时，就不需要移动
了。万一10个空位用完了，再考虑移动使得每个位置之间都有10个空位置。如果删除，就直接删掉，把位置留空即可。这样似乎
暂时解决了插入和删除的移动数据问题。可这对于超过10个同位置数据的插入，效率上还是存在问题。对于数据的遍历，也会以为空
位置太多而造成判断时间上的浪费。而且显然这里空间复杂度还增加了，因为每个元素之间都有若干个空位置。
+ C同学思路：我们反正也是要让相邻元素间留有足够余地，那干脆所有的元素都不要考虑相邻位置了，哪有空位就到哪里，只需要让
每个元素知道它下一个元素的位置在哪里，这样，我们在第一个元素时，就知道第二个元素的位置（内存地址），而找到它。这样
所有的元素我们就可以通过遍历而找到。  
好！太棒了，这个想法非常好！

**1.链式存储结果定义**

在以前顺序存储结构中，每个数据元素只需要存数据元素信息就可以了。线在链式结构中，除了要存数据元素信息外，还需要存储它的后继元素
的存储地址。  
因此，为了表示每个数据元素ai与其直接后继数据元素a(i+1)之间的逻辑关系，对数据ai来说，除了存储其本身的信息之外，还需存储一个指示
其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的
信息称作指针或链。这两部分信息组成数据元素ai的存储映像，称为结点（Node）。  
n个结点(a，的存储映像〉链结成一个链衰，即为线性表（a1,a2，...，an）的链式存储结构，因为此链疆的每个结点中只包啻一个指针域，
所以叫做单链表,单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起，如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_15.jpg)  
对于线性表来说，总得有个头有个尾，链表也不例外.我们把链表中第一个结点的存储位置叫做头指针，那么整个链幸的存取就必须是从头指针开始进行了。
之后的每个结点，其实就是上个的后继指针指向的位置。想象一下，最后一个结点，它的指针指向哪里?  
最后一个，当然就意味着直接后缠不存在了，所以我们规定，线性链者的最后一个结点指针为”空“(通常用NULL或“^”符号表示，如下图)
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_16.jpg)
有时，我们为了更加方便地对链表进行操作，会在单链衰的第一个结点前附设一个结点，称为头结点.头结点的数据域可以不存储任何信息，谁叫它是第-个呢，有
这个特权.也可队存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针，如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_17.jpg)

**2.头指针与头结点的异同**

头指针与头结点的异同点，如下图：
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_18.jpg)

**3.4单链袤的遍历、插入、删除**

`（1）遍历`

遍历链表的算法思路：  
+ 声明一个结点head指向链表第一个结点；
+ 当头结点不为空，就遍历链表，让head的指针向后移动，得到数据，再次循环得值，直至最后一个节点；

`（2）插入`

先来看单链表的插入.假设存储元素e的结点为s，要实现结点p、p->next和s之间逻辑关系的变化，
只需将结点s插入到结点p和p->next之间即可。如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_19.jpg)
根本用不着惊动其他结点，只需要让s->next和p->next的指针做一点改变即可。  
`s->next=p->next；p->next=s;`  
解读这两句代码，也就是说让p的后继结点改成s的后继结点，再把结点s变成p的后继结点。如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_20.jpg)
考虑一下，这两句的顺序可不可以交换?  
如果先p->next=s;再s->next=p->next;会怎么样?如果交换，此时第一句会使得将p->next给覆盖成s的地址了。
那么s->next=p->next，其实就等于s->next=s，这样真正的拥有ai+1数据元素的结点就没了上级.这样的插入操作就是失败的，
造成了临场掉链子的尴尬局面.所以这两句是无论如何不能反的。  
插入结点s后，链表如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_21.jpg)
对于单链表的表头和表尾的特殊情况，操作是相同的，如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_22.jpg)
单链表第i个数据插入结点的算法思路：
+ 声明一结点head指向链表第一个结点；
+ 找到要插入节点的前一节点temp；
+ 单链表的插入标准语句s->next=temp->next;temp->next=s;

`（3）删除`

设存储元素ai的结点为q，要实现将结点q删除单链表的操作，其实就是将它的前继结点的指针绕过，指向它的后继结点即可，如图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_23.jpg)
我们所要做的，实际上就是一步,p->next=p->next->next。  

单链表第i个数据删除结点的算法思路：
+ 声明一结点head指向链表第一个结点；
+ 找到要删除节点的前一节点temp；
+ temp->next=temp->next->next；

**遍历、插入、删除的实现代码算法如下：**


{% highlight java %}
/**
 *功能描述：节点类
 */
public class Node {
	
	//数据
	private int data;
	//指针
	private Node next;
	
	public int getData() {
		return data;
	}
	
	public void setData(int data) {
		this.data = data;
	}
	
	public Node getNext() {
		return next;
	}
	
	public void setNext(Node next) {
		this.next = next;
	}
}

public class LinkList {
	
	public Node head;
	
	LinkList() {
	 
	    this.head = new Node();
	    head.setData(0);
	}
	
	LinkList(int n) { 
		
	    this.head=new Node();
	    Node p,temp;
	    p=head;
	    for(int i = 0;i < n;i++) {
		    temp=new Node();
		    temp.setData(i+1);
		    p.setNext(temp);
		    p = p.getNext();
	    }
	    //插入删除判断时需要，头节点保存表长信息
	    head.setData(n);
	}
	//遍历节点
	public void rList(){
	 
	    Node temp;
	    temp=head;
	    while(temp.getNext() != null) {
		    temp = temp.getNext();
		    System.out.println(temp.getData());
	    }
	}
	//删除节点
	public void dCode(int n) {
	 
	    if(n > head.getData()){
		    System.out.println("找不到第"+n+"个节点");
		    return;
	    }
	    Node temp;
	    temp = head;
	    for(int i = 0;i < n-1;i++) {
		    //要删除的前一节点
		    temp = temp.getNext();
	    }
	    temp.setNext(temp.getNext().getNext());
	    //头结点保存表长信息，表长减1
	    head.setData(head.getData()-1);
	}
	//插入节点
	public void iCode(int n,int d) {
	 
	    if(n > head.getData()+1){
		    System.out.println("找不到第"+n+"个节点");
		    return;
	    }
	    Node s = new Node();
	    s.setData(d);
	    Node temp;
	    temp = head;
	    //n=0或者1或者是负数都是不循环的，此时的temp为head
	    for(int i = 0;i < n-1;i++) {
		    //要插入的前一节点
		    temp = temp.getNext();
	    }
	    s.setNext(temp.getNext());
	    temp.setNext(s);
	}
	 
	public static void main(String args[]) {
		 
	    LinkList l = new LinkList(5);
	    //遍历
	    l.rList();
	    //插入
	    l.iCode(0,8);
	    l.rList();
	    //删除
	    l.dCode(4);
	    l.rList();
	}
}
{% endhighlight %}
[参考链接：链表的面试题及补充](https://www.cnblogs.com/smyhvae/p/4782595.html)
单链表插入和删除算法都是由两部分组成第一部分就是遍历查找第i 个元素，第二部卦就是插入和删除元素。  
从整个算法来说，我们很容易推导出：它们的时间且最度都是O(n)。如果在我们
不知道第i个元素的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺
序存储结构是没有太大优势的.但如果，我们希望从第i个位置，插入10个元素，对
于顺序存储结构意味着，每一次插入都需要移动n-i个元素，每次都是O(n)。而单
链表，我们只需要在第一次时，找到第i个位置的指针，此时为O(n)，接下来只是简
单地通过赋值移动指针而已，时间复杂度都是O(1)。显然，`对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。`

**3.5单链表结构与顺序存储结构优缺点**

简单地对单链表结构和顺序存储结构做对比：
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_24.jpg)
通过上面的对比，我们可以得出一些经验性的结论：
+ 若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。比如说游戏开发中，
对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况都是读取，所以应该考虑用顺序存储结构。而游戏中的玩家的武器或者装备列表，
随着玩家的游戏过程中，可能会随时增加或删除，此时再用顺序存储就不大合适了，单链表结构就可以大展擎脚。当然，这只是简单的类比，
现实中的软件开发，要考虑的问题会复杂的很多。
+ 当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表
的大致长度，比如一年12 个月，一周就是星期一至星期日共七天，这种用顺序存储结构效率会高很多。
  
总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，
来综合平衡采用哪种数据结构更能满足需求和性能。

**3.6静态链表**

不做介绍（为了完整性，了解一下即可）

**3.7循环链表**

举个例子：

>你是一业务员，家在上海，需要经常出差，行程就是上海到北京路上的城市，找客户谈生意或分公司办理业务。你从上海出发，乘火车路经多个城市停留
后，再乘飞机返回上海，以后，每隔一段时间，你基本还要按照这样的行程开展业务。如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_25.jpg)
有一次，你先到南京开会，接下来要对以上的城市走一遍，此时有人对你说，不行，你得从上海开始，因为上海是第一站. 你会对这人说什么?神经病。
哪有这么傻的，直接回上海根本没有必要，你可以从南京开始，下站蚌埠，直到北京，之后再考虑走完上海及苏南的几个城市。
显然这表示你是从当中一个结点开始遍历整个链表，这都是原来的单链表结构解决不了的问题。  
事实上，把北京和上海之间连起来，形成一个环就解决了前面所面临的困难。

**将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一
个环，这种头尾相接的单链表称为单循环链表，简称循环链表。**  

从刚才的例子，可以总结出，循环链表解决了一个很麻烦的问题。如何从当中一个结点出发，访问到链表的全部结点。

`为了使空链表与非空链表处理一致，我们通常设一个头结点，当然，这并不是说，循耳链表一定要头结点，这需要注意。`

对于非空的循环链表如下图所示：
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_26.jpg)
其实循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断p->next是否为空，现在则是p->next不等于头结点，
则循环未结束。在单链表中，我们有了头结点时，我们可以用O(1)的时间访问第一个结点，但对于要访问到最后一个结点，
却需要O(n)时间，因为我们需要将单链表全部扫描一遍。  
有没有可能用O(1)的时间由链表指针访问到最后一个结点呢?当然可以。  
不过我们需要改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表，
此时查找开始结点和终端结点都很方便了。如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_27.jpg)
从上图中可以看到，终端结点用尾指针rear 指示，则查找终端结点是O(1)，而开始结点，其实就是rear->next->next,其时间复杂度也为O(1)。

要将两个循环链表合并成一个表时，有了尾指针就非常简单了，比如下面的这两个循环链表，它们的尾指针分别是rearA 和rearB，如图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_28.jpg)
要想把它们合并，只需要如下的操作即可。
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_29.jpg)

```
p=rearA->next; /*1.保存A表的头节点*/
rearA->next=rearB->next->next; /*2.将本是指向B表的第一个节点（不是头节点）赋值给rearA->next*/
rearB->next=p; /*3.将原A表的头节点赋值给rearB->next*/
```

**3.8双向链表**

我们在单链表中，有丁next 指针，这就使得我们要查找下一结点的时间复杂度为0(1)。可是如果放们要查找的是上一结点的话，
那最坏的时间复杂度就是O(n)了，因为我们每次都要从头开始遍历查找。  
双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，
一个指向直接后继，另个指向直接前驱。  
既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。  
非空的循环的带头结点的双向链表。如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_30.jpg)
双向链表既然是比单链表多了如可以反向遍历查找等数据结构，那么也就需要付出一些小的代价：在插入和
删除时，需要更改两个指针变量。  
插入操作时，其实井不复杂，不过顺序很重要，千万不能写反了。  
我们现在假设存储元素e的结点为s，要实现将结点s插入到结点p和p->next之间需要下面几步，如图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_31.jpg)
```
s->prior=p;/*把p赋值给s的前驱，如图第1步*/
s->next=p->next;/*把p->next赋值给s的后继，如图第2步*/
p->next->prior=s;/*把s赋值给p-next的前驱，如图第3步*/
p->next=s;/*把s赋值给p的后继，如图第4步*/
```

若要删除结点p ，只需要下面两步骤，如图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_32.jpg)
```
p->prior->next=p->next;/*祀p->next赋值给p->prior的后继*/
p->next->prior->=p->prior;/*把p->prior赋值给p->next的前驱*/  
```
双向链表相对于单链表来说，要更复杂一些，毕竟它多了prior指针，对于插入和删除时，需要格外小心。
另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。不过，由于它良好的对称性，使得对某个
结点的前后结点的操作，带来了方便， 可以有效提高算法的时间性能。 说白了，就是用空间来换时间。

#### 3.3总结

这一章，主要讲的是线性表。  
先谈了它的定义，线性表是零个或多个具有相同类型的数据元素的有限序列。然后就线性表的两大结构做了讲述，先讲的是比较容易的顺序存储结构，指
的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。后来是我们的重点，由于顺序存储结构的插入和删除操作不方便，
引出了链式存储结构. 它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点.然后我们分别就链式存储结构的不同形式，
如单链表、循环链表和双向链表做了讲解。如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_33.jpg)

### 4、栈与队列

![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_34.jpg)
#### 4.1栈

##### 4.1.1栈的定义

类似弹夹中的子弹一样先进去，却要后出来，而后进的，反而可以先出来的数据结构：栈。

>在我们软件应用中，栈这种后进先出数据结构的应用是非常普遍的。比如你用浏览器上网时。不管什么浏览器都有一个'后退'键，你点击后可以按访问顺序的逆序
加载浏览过的网页。比如你本来看着新闻好好的，突然看到一个链接说，有个可以让你年薪100万的工作，你毫不犹豫点击它，跳转进去一看，这都是啥呀，具体内容我
也就不说了，骗人骗得一点水平都没有。此时体还想回去继续看新闻，就可以点击左上角的后退键。即使你从一个网页开始，连续点了几十个链接跳转，你点"后退'
时， 还是可以像历史倒退一样，回到之前浏览过的某个页面。

栈(stack)是限定仅在表尾进行插入和删除操作的线性表。  
我们把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom),不含任何数据元素的栈称为空栈。栈又称为后进先出的线性表，简称LIFO结构。  
理解栈的定义需要注意：  
首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。只不过它是一种特殊的线性表而已。
定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。它的特殊之处就在于限制了这个线性表的插入和删除位置，
它始终只在栈顶进行。这也就使得栈底是固定的，最先进栈的只能在栈底。  
`栈的插入操作，叫作进栈，也称压栈、入栈；栈的删除操作，叫作出栈，也有的叫作弹栈。`
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_35.jpg)

##### 4.1.2进栈出栈变化形式

这个最先进栈的元素，是不是就只能是最后出栈呢?  
答案是不一定，要看什么情况。栈对线性表的插入和删除的位置进行了限制，并没有对元素进出的时间进行限制，也就是说，
在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证是栈顶元素出栈就可以。  
举例来说， 如果我们现在是有3个整型数字元素1 、2、3依次进栈，会有哪些出栈次序呢？
+ 第一种：1 、2 、3 进，再3 、2 、1 出。这是最简单的最好理解的一种，出栈次序321。
+ 第二种：1进，1出，2进，2出，3进，3出。也就是进一个就出一个，出栈次序123。
+ 第三种：1进，2进，2出，1出，3进，3出。出栈次序为213。
+ 第四种：1进，1出，2进，3进，3出，2出。出栈次序为132。
+ 第五种：1进，2进，2出，3进，3出，1出。出栈次序为231。

有没有可能是312这样的次序出栈呢?答案是肯定不会。因为3 先出栈，就意味着，3曾经进栈，既然3都进栈了，那也就意味着，1和2已经进栈了，此时，
2一定是在1的上面，就是直接近栈顶，那么出栈只可能是321，不然不满足123依次进栈的要求，所以此时不会发生1比2先出栈的情况。  
从这个简单的例子就能看出，只是3个元素，就有5种可能的出栈次序，如果元素数量多，其实出栈的变化将会更多的。这个知识点一定耍弄明白。

##### 4.1.3栈的顺序存储结构及实现

**1.栈的顺序存储结构**

既然栈是线性表的特例，那么栈的顺序存储其实也是线性表顺序存储的简化。简称为顺序栈。线性表是用数组来实现的，想想看，对于栈这种只能一头插入删除
的线性表来说，用数组哪一端来作为栈顶和栈底比较好?  
下标为0的一端作为栈底比较好，因为首元素都存在栈底，变化最小，所以让它作栈底。  
我们定义一个top变量来指示栈顶元素在数组中的位置，这top就如同中学物理学过的游标卡尺的游标，它可以来回移动，意味着栈顶的top可以变大变小，
但无论如何游标不能超出尺的长度。同理，若存储栈长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于O，因此通常把空栈
的判定条件定为top等于-1。若现在有一个栈，StackSize是5。则栈通情况、空栈和栈满的情况如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_36.jpg)

**2.栈的顺序存储结构：进栈、出栈的实现**

代码实现如下：

{% highlight java %}
public class MyStack_Text {

	static class mystack{
    
        int mytop;
        int stack[];
        
        public mystack(int num) {
            mytop=-1;
            stack=new int[num];
        }
        /**
         * 出栈
         */
        void mypop(){
        
            mytop--;
        }
        /**
         * 入栈
         * @param x
         */
        void mypush(int x){
        
            mytop++;
            stack[mytop]=x;
            
        }
        /**
         * 判空
         * @return
         */
        Boolean myisempty(){
        
            if(mytop==-1)
                return true;
            else
                return false;
        }
        /**
         * 取栈顶元素
         * @return
         */
        int mypeek(){
        
            int peek=stack[mytop];
            return peek;
        }
        /**
         * 栈大小
         * @return
         */
        int mysize(){
        
            return mytop+1;
        }
    }
    
    
    public static void main(String[] args) {
        mystack myStack=new mystack(20);
        myStack.mypush(1);
        myStack.mypush(2);
        myStack.mypush(3);
        myStack.mypush(4);
        System.out.println("栈大小为"+myStack.mysize());
        if(!myStack.myisempty()){
            for(int i=myStack.mytop;i>=0;i--){
                int get=myStack.mypeek();
                myStack.mypop();
                System.out.println(get);
            }
        }
    }
}
{% endhighlight %}

##### 4.1.4两栈共享空间

其实栈的顺序存储还是很方便的，因为它只准栈顶进出元素，所以不存在线性表插入和删除时需要移动元素的问题。不过它有一个很大的缺陷，就是必须事先确定数
组存储空间大小，万一不够用了，就需要编程手段来扩展数组的容量，非常麻烦。对于一个栈，我们也只能尽量考虑周全，设计出合适大小的数组来处理，但对于两个相
同类型的栈，我们却可以做到最大限度地利用其事先开辟的存储空间来进行操作。

>打个比方，两个大学室友毕业同时到北京工作，开始时，他们觉得住了这么多年学校的集体宿舍，现在工作了一定要有自己的私密空间。于是他们都希望租房时能找
到独住的一居室，可找来找去却发现，最便宜的一居室也要每月1500元，地段还不好，实在是承受不起，最终他俩还是合租了一套两居室，一共2000元，各出一半，还不错。
对于两个一居室，都有独立的卫生间和厨房，是私密了，但大部分的空间的利用率却不高。而两居室，两个人各有卧室，还共享了客厅、厨房和卫生间，
房间的利用率就显著提高，而且租房成本也大大下降了。 
 
同样的道理，如果我们有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，
而另一个栈还有很多存储空间空闲。这又何必呢?我们完全可以用一个数组来存储两个栈，只不过需要点小技巧。  
数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈底为栈的末端，即下标为数组长度n-l处。这
样，两个栈如果增加元素，就是两端点向中间延伸。如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_38.jpg)
其实关键思路是它们是在数组的两端，向中间靠拢。topl和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。  
从这里也就可以分析出来，栈1为空时，就是topl等于-1时；而当top2等于n时，即是栈2为空时，那什么时候栈满呢?  
想想极端的情况，若栈2是空栈，栈1的topl等于n-1时， 就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。但更多的情况，其实就是我刚才
说的，两个栈见面之时，也就是两个指针之间相差1时，即topl + 1 == top2 为栈满。

代码实现如下：

{% highlight java %}
public class BothStack<T> {

    private Object[] element; //存放元素的数组  
    
    private int stackSize;  // 栈大小  
      
    private int top1; //栈1的栈顶指针  
      
    private int top2; //栈2的栈顶指针  
      
      
    /** 
     * 初始化栈 
     * @param size 
     */  
    public BothStack(int size){  
        element = new Object[size];  
        stackSize = size;  
        top1 = -1;  
        top2 = stackSize;  
    }  
      
      
    /** 
     * 压栈 
     * @param i 第几个栈 
     * @param o 入栈元素 
     * @return  
     */  
    public boolean push(int i , Object o){  
          
        if(top1 == top2 - 1)  
            throw new RuntimeException("栈满！");    
        else if(i == 1){  
            top1++;  
            element[top1] = o;  
        }else if(i == 2){  
            top2--;  
            element[top2] = o;  
        }else  
            throw new RuntimeException("输入错误！");  
              
        return true;  
    }  
      
    /** 
     * 出栈 
     * @param i 
     * @return 
     */  
    @SuppressWarnings("unchecked")  
    public T pop(int i){  
          
        if(i == 1){  
            if(top1 == -1)  
                throw new RuntimeException("栈1为空");  
            return (T)element[top1--];  
        } else if(i == 2){  
            if(top2 == stackSize)  
                throw new RuntimeException("栈2为空");  
            return (T)element[top2++];  
        } else    
        throw new RuntimeException("输入错误！");  
                  
    }  
      
      
    /** 
     * 获取栈顶元素 
     * @param i 
     * @return 
     */  
    @SuppressWarnings("unchecked")  
    public T get(int i){  
          
        if(i == 1){  
            if(top1 == -1)  
                throw new RuntimeException("栈1为空");  
            return (T)element[top1];  
        } else if(i == 2){  
            if(top2 == stackSize)  
                throw new RuntimeException("栈2为空");  
            return (T)element[top2];  
        } else    
        throw new RuntimeException("输入错误！");  
    }  
      
      
    /** 
     * 判断栈是否为空 
     * @param i 
     * @return 
     */  
    public boolean isEmpty(int i){  
          
        if(i == 1){  
            if(top1 == -1)  
                return true;  
            else  
                return false;  
        } else if(i == 2){  
            if(top2 == stackSize)  
                return true;  
            else  
                return false;  
        } else    
        throw new RuntimeException("输入错误！");  
    }  
      
    /**
     * 遍历  
     */
    @SuppressWarnings("unchecked")  
    @Override  
    public String toString(){  
          
        String str1 = "栈1：[";  
        String str2 = "栈2：[";  
          
        for(int i=top1;i>=0;i--){  
            if(i == 0)  
                str1 = str1 + (T)element[i];  
            else  
                str1 = str1 + (T)element[i] + ",";  
        }  
          
        str1 += "]";  
          
        for(int i=top2;i<stackSize;i++){  
            if(i == stackSize-1)  
                str2 = str2 + (T)element[i];  
            else  
                str2 = str2 + (T)element[i] + ",";  
        }  
          
        str2 += "]";  
          
        return str1 + "\n\r" + str2;  
    } 
    
    public static void main(String[] args) {
    	BothStack bothStack = new BothStack(20);
    	bothStack.push(1,1);
    	bothStack.push(1,2);
    	bothStack.push(1,3);
    	bothStack.push(1,4);
    	bothStack.push(2,5);
    	bothStack.push(2,6);
    	bothStack.push(2,7);
    	bothStack.push(2,8);
    	System.out.println(bothStack.toString());
    	if(!bothStack.isEmpty(1)){
    		for(int i = bothStack.top1;i >= 0;i--){
                Object get  = bothStack.get(1);
                bothStack.pop(1);
                System.out.println(get);
            }
    	}
    	if(!bothStack.isEmpty(2)){
    		for(int i = bothStack.top2;i<bothStack.stackSize;i++){
                Object get  = bothStack.get(2);
                bothStack.pop(2);
                System.out.println(get);
            }
    	}
    	//bothStack.pop(2);
    }
}
{% endhighlight %}

事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。就像买卖股票一样，体买入时，一定是有
一个你不知道的人在做卖出操作。有人赚钱，就一定是有人赔钱。这样使用两栈共享空间存储方法才有比较大的意义。否则两个栈都在不停地增长，那很快就会因栈满而
溢出了。  
当然，这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果是不相同数据类型的栈，这种方法不但不能更好地处理问题，反而会使问题变得更复杂，
大家要注意这个前提。  

##### 4.1.5栈的链式存储结构及实现

**1.栈的链式存储结构**

讲完了栈的顺序存储结构，我们现在来看看栈的链式存储结构，简称为链栈。

想想看，栈只是栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢?由于单链表有头指针，而栈顶指针也是必须的，那干嘛不让他俩合二为一呢，所以比较
好的办法是把栈顶放在单链表的头部。另扑，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_39.jpg)
对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统已经面临死机崩溃的情况，而不是这个链栈是
否溢出的问题.但对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL的时候。

**2.栈的链式存储结构：进栈、出栈的操作**

对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针，入下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_40.jpg)
```
s->data=e;
s->next=top;/*把当前的栈顶元素赋值给新节点的直接后继*/
top=s;/*将新的节点s赋值给栈顶指针*/
```
至于链栈的出栈pop操作，如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_41.jpg)
```
p=top/*将栈顶节点赋值给p*/
top=top->next;/*使得栈顶指针下移一位，指向后一节点*/
```
对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为O(1)。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的
优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别和线性表中讨论的一样，`如果
栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。`

##### 4.1.6栈的作用

用数组或链表直接实现功能不就行了吗?干嘛要引入栈这样的数据结构呢?  
其实这和我们明明有两只脚可以走路，干嘛还要乘汽车、火车、飞机一样。理论上，陆地上的任何地方，你都是可以靠双脚走到的，可那需要多少时间和精力呢?  
栈的引人简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。
所以现在的许多高级语言，比如java、C#等都有对栈结构的封装，可以不用关注它的实现细节，就可以直接使用Stack的push和pop方法，非常方便。

##### 4.1.7栈的应用：递归

栈有一个很重要的应用：在程序设计语言中实现了迪归。那么什么是递归呢?  

当你往镜子前面一站，镜子里面就有一个你的像。但你试过两面镜子一起照吗?如果A、B两面镜子相互面对面放着，你往中间一站，嘿，两面镜子里都有你的千百个
“化身”。为什么会有这么奇妙的现象呢?原来，A镜子里有B镜子的像。B镜于里也有A镜子的像，这样反反复复，就会产生一连串的”像中像“。这是一种递归现象。先
来看一个经典的递归例子。

**斐波那契数列实现:**

说如果兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔都不死，那么一年以后可以繁殖多少对兔子呢?

我们拿新出生的一对小兔子分析一下：第一个月小兔子没有繁殖能力，所以还是一对，两个月后，生下一对小兔子数共有两对，三个月以后，老兔子又生下一对，因
为小兔子还没有繁殖能力，所以一共是三对...依次类推可以列出下表
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_42.jpg)
表中数字1，1，2，3，5，8，13 构成了一个数列。这个数列有个十分明显的特点，那是前面相邻两项之和，构成了后一项。如果我们用数学函数来定义就是：
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_43.jpg)
先考虑一下，如果我们要实现这样的数列用常规的迭代的办法如何实现?假设我们需要打印出前5个月的斐波那契数列。
{% highlight java %}
public static void main(String[] args) {
    	
	int i = 0;
	int[] a = new int[6];
	a[0] = 0;
	a[1] = 1;
	System.out.println(a[0]);
	System.out.println(a[1]);
	for(i = 2;i <= 5;i++){
		a[i] = a[i-1] + a[i-2];
		System.out.println(a[i]);
	}
}
{% endhighlight %}

`用递归的方式实现：`

{% highlight java %}
public static void main(String[] args) {
    	
	for(int i = 0;i <= 5;i++){
		System.out.println(Fib(i));
	}
}
    
public static int Fib(int i){
	if(i < 2){
		return i == 0 ? 0 : 1;
	}
	return Fib(i - 1) + Fib(i - 2);
}
{% endhighlight %}

函数怎么可以自己调用自己？听起来有些难以理解，不过你可以不要把一个递归函数中调用自己的函数看作是在调用自己，而就当它是在调另一个函数。
只不过，这个函数和自己长的一样而已。  
我们来模拟代码中的Fib(i)方法，当i=5时的执行过程，如下图
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_44.jpg)

**递归定义**

在高级语言中，调用自己和其他函数井没有本质的不同。我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。  
当然，写递归程序最怕的就是陷入永不结束的无穷递归中，所以，每个递归定义必须至少有一个条件， 满足时递归不再进行，即不再引用自身而是返回值退出。
比如刚才的例子，总有一次递归会使得i<2的，这样就可以执行retum i的语句而不用继续递归了。  

对比了两种实现斐波那契的代码。迭代和递归的区别是迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更简洁、更容易让人理解，
从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。选代则不需要反复调用函数和占用额外的内存。
因此我们应该视不同情况选择不同的代码实现方式。

>前面我们已经看到递归是如何执行它的前行和退回阶段的。递归过程退回的顺序是它前行顺序的逆序。在退回过程中，可能要执行某些动作，包括恢复在前行过程中
存储起来的某些数据。这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合栈这样的数据结构，因此，
编译器使用栈实现递归就没什么好惊讶的了。简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压人栈中。在退回阶段，
位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。当然，对于现在的高级语言，
这样的递归问题是不需要用户来管理这个栈的，一切都由系统代劳了。







 




















