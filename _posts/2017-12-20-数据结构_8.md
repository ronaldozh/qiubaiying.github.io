---
layout:     post
title:      数据结构_8
subtitle:   查找
date:       2017-12-20
author:     赵小恒
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - 数据结构
---

### 8、查找

>查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。

#### 8.1查找概论  
只要你打开电脑，就会涉及到查找技术。如炒股软件中查股票信息、硬盘文件中找照片、玩游戏时在内存中查找攻击力、
魅力值等数据修改用来作弊等，都要涉及到查找。当然，在互联网上查找信息就更加是家常便饭。所有这
些需要被查的数据所在的集合，我们给它一个统称叫查找表。  
**查找表(Search Table)是由同一类型的数据元素（或记录） 构成的集合。**例如
图8-2-1 就是一个查找表。  
**关键字(Key)是数据元素中某个据项的值，又称为键值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项(字段)，
我们称为关键码，如图8-2-1 中①和②所示。  
若此关键字可以唯一地标识一个记录，则称此关键字为主关键宇(Primary Key) 。注意这也就意味着，对不同的记录，
其主关键字均不相同。主关键字所在的数据项称为主关键码，如图8-2-1 中③和圈4所示。  
**那么对于那些可以识别多个数据元素(或记录) 的关键字，我们称为次关键字(Secondary Key)**，如图8-2-1中⑤所示。
次关键字也可以理解为是不以唯一标识一个数据元素(或记最)的关键字，它对应的数据项就是次关键码。
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_1.jpg)  
若表中存在这样的一个记录，则称查找是成功的，此时查找的结果给出整个记录的信息，
或指示该记录在查找表中的位置。比如图8-2-1所示，如果我们查找主关键码"代码'的主关键字为"sh601398"的记录时，
就可以得到第2条唯一记录。如果我们查找次关键码”涨跌额“ 为“- 0.11"的记录时，就可以得到两条记录。  
若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可给出一个“空”记录或”空“指针。  
查找表按照操作方式来分有两大种：静态查找表和动态查找表。  
静态查找表(Static Search Table)：只作查找操作的查找表。它的主要操作有：  
( 1 ) 查询某个“特定的”数据元素是否在查找表中。
( 2 ) 检索某个“特定的”数据元素和各种属性。  
按照我们大多数人的理解，查找， 当然是在已经有的数据中找到我们需要的。静态查找就是在干这样的事情，
不过，现实中还有存在这样的应用：查找的目的不仅仅只是查找。  
比如网络时代的新名词，如反应年轻人生活的“蜗居”、“蚁族”、”房奴“、“啃老”等，如果需要将它们收
录到汉语词典中，显然收录时就需要查找它们是否存在，以及找到如果不存在时应该收录的位置。
再比如，如果你需要对某网站上亿的注册用户进行清理工作，注销一些非法用户，你就需查找到它们后进行删除，
删除后其实整个查找表也会发生变化。对于这样的应用，我们就引入了动态查找表。  
**动态查找表(Dynamic Search Table) 在查找过程中同时插入查找表中不存在的数据元素，
或者从查找表中删除已经存在的某个数据元素。**显然动态查找表的操作就是两个：
( 1 ) 查找时插入数据元素。
( 2 ) 查找时删除数据元素。
为了提高查找的效率， 我们需要专门为查找操作设置数据结构，这种面向查找操作的数据结构称为查找结构。  
从逻辑上来说，查找所基于的数据结构是集合，集合中的记录之间没有本质关系。可是要想获得较高的查找性能，
我们就不能不改变数据元素之间的关系，在存储时可以将查找集合组织成表、树等结构。  
例如，对于静态查找表来说，我们不妨应用线性表结构来组织数据，这样可以使用顺序查找算法，如果再对主关键字排序，
 则可以应用折半查找等技术进行高效的查找。  
如果是需要动态查找，则会复杂一些，可以考虑二叉树排序树的查找技术。
另外，还可以用散列表结构来解决一些查找问题，这些技术都将在后面的讲解中说明。

#### 8.2顺序表查找  
试想下，要在散落的一大堆书中找到你需要的那本有多么麻烦。碰到这种情况的人大都会考虑做一件事，那就是把这些书排列整齐，
比如竖起来放置在书架上，这样根据书名，就很容易查找到需要的图书。  
散落的图书可以理解为一个集合，而将他们排列整齐，就如同是将此集告构造成一个线性表。我们要针对这一线性表进行查找操作，
因此它就是**静态查找表**。  
此时图书尽管已经排列整齐，但还没有分类，因此我们要找书只能从头到尾或从尾到头一本一本查看，直到找到或全部查找完为止.。
这就是我们现在要讲的顺序查找。  
顺序查找( Sequential Search ) 又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个(或最后一个)记录开始，逐个进行记录的关键字和给定值比
较，若某个记录的关键字和结定值相等，则查找成功，找到所查的记录，如果直到最后一个( 或第一个) 记录，其关键字和给定值比校都不等时，则表中没有所查的记
录，查找不成功。  

##### 8.2.1顺序表查找算法 

{% highlight java %}
public static int orderSearch(int searchKey,int[] array){  
    if(array==null||array.length<1)  
        return -1;  
    for(int i=0;i<array.length;i++){  
        if(array[i]==searchKey){  
            return i;  
        }  
    }  
    return -1;  
      
}
{% endhighlight %}  
对于这种顺序查找算法来说，查找成功最好的情况就是在第一个位置就找到了，算法时间复杂度为O（1），最坏的情况是在最后一位置才找到，需要n次比较，时间
复杂度为O(n)，当查找不成功时，需要n+1次比较，时间复杂度为O（n）。我们之前推导过，关键字在任何一位置的概率是相同的，所以平均查找次数为(n+l)/ 2。
所以最终时间复杂度还是O（n）。  
很显然，顺序查找技求是有很大缺点的，n 很大时，查找效率极为低下，不过优点也是有的，这个算法非常简单，对静态查找表的记录没有任何要求，在一些小型数
据的查找时，是可以适用的。  
另外，也正由于查找概率的不同，我们完全可以将容易查找到的记录放在前面，而不常用的记录放置在后面，效率就可以有大幅提高。

#### 8.3有序表查找

我们如果仅仅是把书整理在书架上，要找到一本书还是比较困难的，也就是刚才讲的需要逐个顺序查找。但如果我们在整理书架时，特图书按照书名的拼音排序放
置，那么要找到某一本书就相对容易了。说白了，就是对图书做了有序排列，一个线性表有序时，对于查找总是很有帮助的。

##### 8.3.1折半查找

折半查找( Binary Search ) 技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序(通常从小到大有序)。线性表必须采用顺序存储。折半查找的基
本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查
找，若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。

**折半查找算法**

{% highlight java %}
public static int binarySearch(int[] array, int searchKey) {  
  
    int low = 0;  
    int high = array.length - 1;  
    while (low <= high) {  
        int middle = (low + high) / 2;  
        if (searchKey == array[middle]) {  
            return middle;  
        } else if (searchKey < array[middle]) {  
            high = middle - 1;  
        } else {  
            low = middle + 1;  
        }  
    }  
    return -1;  
} 
{% endhighlight %}  
折半算法的时间直如度为O(logn )，它显然远远好于顺序查找的O(n)时间复杂度了。  
不过由于折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好了。但对于需要频繁执行插入或删除操作的数
据跑集来说，维护有序的排序会带来不小的工作量，那就不建议使用。  

##### 8.3.2插值查找

现在我们的新问题是，为什么一定要折半，而不是折四分之一或者折更多呢?
打个比方，在英文词典里查“app "，你下意识里翻开词典是翻前面的书页还是后面的书页呢？如
果再让体查” zoo“，你又怎么查？很显然， 这里体绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。  
同样的，比如要在取值范围0~10000之间100个元素从小到大均匀分布的数组中查找5，我们自然会考虑丛数组下标较小的开始查找。  
差值算法只是折半查找的一种改进。具体改进方法略...  

##### 8.3.3斐波那契查找

`略...`

#### 8.4线性索引查找

我们前面讲的几种比较高效的查找方法都是基于有序的基础之上的，但事实上，很多数据集可能增长非常快，例如，某些微博网站或大型论坛的帖子和回复总数每天
都是成百万上千万条，或者一些服务器的日志信息记录也可能是海量数据，要保证记录全都是按照当中的某个关键字有序，其时间代价是非常高昂的，
所以这种数据通常都是按先后顺序存储。那么对于这样的查找表，我们如何能够快速查找到需要的数据呢？办法就是：索引。  
数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构。**索引就是把一个关键字与它对应的记录相关联的过程**， 一个索引由若
干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。  
索引按照结构可以分为线性索引、树形索引和多级索引。我们这里就只介绍线性索引技术.。**所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。我们重
点介绍三种线性索引，稠密索引、分块索引和倒排索引。

##### 8.4.1稠密索引

我母亲年纪大了，记忆力不好，经常在家里找不到东西，于是她想到了一个办法。她用一个小本子记录了家里所有小东西放置的位置，比如户口本放在右手床头柜下
面抽屉中，针线放在电视柜中间的抽屉中，总之，她老人家把这些小物品的放置位置都记录在小本子上，并且每隔
一段时间还按照本子整理一遍家中的物品，用完都放回原处，这样她就几乎再没有找不到东西。  
从这件事就可以看出，家中的物品尽管是无序的，但是如果有一个小本子记录，寻找起来也是非常容易，而这小本子就是索引。  
稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，如图8-5-2所示。  
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_2.jpg)    
刚才的小例子和稠密索引还是略有不同，家里的东西毕竟少，小本子再多也就几十页，全部翻看完就几分钟时间，而相密索引要应对的可能是成千上万的数据，因此
**对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。**  
索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率。比如图8-5-2中，我要查找主键字是18的记录，
如果直接从右侧的数据表中查找，那只能顺序查找，需要查找6次才可以查到结果。
而如果是从左侧的索引表中查找，只需两次折半查找就可以得到18对应的指针，最终查找到结果。  
这显然是稠密索引优点，但是如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁
盘，查找性能反而大大下降了。

##### 8.4.2分块索引

回想一下图书馆是如何藏书的。显然它不会是顺序摆放后，给我们一个稠密索引表去查，然后再找到书给你。图书馆的图书分类摆放是一门非常完整的科学体系，而
它最重要的一个特点就是分块。  
稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个
索引项，从而减少索引项的个数。  
**分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：  
+ 块内无序，即每一块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我
们不要求块内有序。  
+ 块间有序， 例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键
字...因为只有块间有序，才有可能在查找时带来效率。  

对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。如图8-5-4 所示，我们定义的分块索引的索引项结构分为三个数据项：
+ 最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大；
+ 存储了块中的记录个数，以便于循环时使用；
+ 用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。  
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_3.jpg)    
在分块索引表中查找，就是分两步进行：  
+ 在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，因此很容易利用折半、插值等算法得到结果。例如，在图8-5-4的数据集中
查找62，我们可以很快可以从左上角的索引表中由57<62<96得到62在第三个块中。
+ 根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找。  

分块索引的效率比顺序查找的O(n)是高了不少，不过显然它与折半查找的O(n)相比还有不小的差距.。因此在确定所在块的过程中，由于块间有序，所以可
以应用折半、插值等手段来提高效率。  
总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据库表查找等技术的应用当中。

##### 8.4.3倒排索引

我不知道大家有没有对搜索引擎好奇过，无论你查找什么样的信息，它都可以在极短的时间内给你一些结果，是什么算法技术达到这样的高效查找呢？  
我们在这里介绍最简单的，也算是最基础的搜索技术一一倒排索引。  
我们来看样例，现在有两篇极短的英文“文章”一一其实只能算是句子，我们暂认为它是文章，编号分别是1和2。  
1. Books and friends should be few but good （读书如交友， 应求少而精。）
2.  A good book is a good friend (好书如挚友。)  

假设我们忽略掉如“books”、“friends”中的复数“s”以及如“A” 这样的大小写差异。我们可以整理出这样一张单词表，如表在8-5-1所示，并将单词做了排序，也就
是表格显示了每个不同的单词分别出现在哪篇文章中，比如“good”它在两篇文章中都有出现，而“i s”只是在文章2中才有。
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_4.jpg)    
有了这样一张单词表，我们要搜索文章，就非常方便了。如果你在搜索框中填写“book”关键字。系统就先在这张单词表中有序查找“book”，找到后将它对应的文章
编号1和2的文章地址（通常在搜索引擎中就是网页的标题和链接）返回，并告诉你，查找到两条记录，用时0 . 0001秒。由于单词表是有序的，查找效率很高，返回的
又只是文章的编号，所以整体速度都非常快。  
如果没有这张单词表，为了能证实所有的文章中有还是没有失键字“book”，则需要对每一篇文章每个单词顺序查找。在文章数是海量的情况下，这样的做法只存在
理论上可行性，现实中是没有人愿意使用的。  
在这里这张单词表就是索引表，索引项的通用结构是：
+ 次关键码，例如上面的“英文单词”；
+ 记录号表，例如上面的“文章编号”。  
**其中记录号表存储具有相同次关键字的所有记录的记录号(可以是指向记录的指针或者是该记录的主关键字)。这样的索引方法就是倒排索引(inverted index)**。倒排
索引源于实际应用中需要根据属性（或宇段、次关键码）的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录
来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引。  
倒排索引的优点显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长，比如上例有7 个
单词的文章编号只有一个，而“book”、“friend”、“good”有两个文章编号，若是对多篇文章所有单词建立倒排索引，那每个单词都将对应相当多的文章编号，
维护比较困难，插入和删除操作都需要作相应的处理。  
当然，现实中的搜索技术非常复杂，比如我们不仅要知道某篇文章有要搜索的关键字，还想知道这个关键字在文章中的哪些地方出现，这就需要我们对记录号表做一
些改良。再比如，文章编号上亿，如果都用长数字也没必要，可以进行压缩，比如三篇文章的编号是“112，115，119”，我们可以记录成“112，+3，+4”，
即只记录差值，这样每个关键字就只占用一两个字节。 甚至关键字也可以压缩，比如前一条记录的关键字是“and”而后一条是“android" ， 那么后面这个
可以改成“<3 ，android >”，这样也可以起到压缩数据的作用。再比如搜索时，尽管告诉你有几千几万条查找到的记录，但
其实真正显示给你看的，就只是当中的前10或者20条左右数据，只有在点击下一页时才会获得后面的部分索引记录，这也可以大大提高了整体搜索的效率。

#### 8.5二叉排序树

假设查找的数据集是普通的顺序存储，那么插入操作就是将记录放在表的末端，给表记录数加一即可，删除操作可以是删除后，后面的记录向前移，也可以是要删除
的元素与最后个一个元素互换，表记录数减一，反正整个数据集也没有什么顺序，这样的效率也不错。应该说，插入和删除对于顺序存储结构来说，效率是可以接受的，
但这样的表由于无序造成查找的效率很低，前面我们有讲解，这就不在重复。  
如果查找的数据集是有序线性表，并且是顺序存储的，查找可以用折半、插值、斐波那契等查找算法来实现，可惜，因为有序，在插入和删除操作上，就需要耗费大
量的时间。   
有没有一种既可以使得插入和删除效率不错，又可以比较高效率地实现查找的算法呢？还真有。  
我们在8.1节把这种需要在查找时插入或删除的查找表称为动态查找表。我们现在就来看看什么样的结构可以实现动态查找表的高效率。  
如果在复杂的问题面前，我们束手无策的话，不妨先从最最简单的情况入手.现在我们的目标是插入和查找同样高效。假设我们的数据集开始只有一个数{62}，然后
现在需要将88插入数据集，于是数据集成了{62，88}，还保持着从小到大有序。再查找有没有58 ，没有则插入，可此时要想在线性表的顺序存储中有序，
就得移动62和88的位置，如图8-6-2左图，可不可以不移动呢？当然是可以，那就是二叉树结构。当我们用二叉树的方式时，首先我们将第一个数62定为根结点，
88因为比62大，因此让它做62的右子树，58因比62小，所以成为它的左于树。此时58的插入并没有影响到62与88的关系，如图8-6-2右图所示。
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_5.jpg)   
也就是说，若我们现在需要对集合(62 ，88， 58 ，4 7， 35 ，73，51， 99，37，93)做查找，在我们打算创建此集合时就考虑用二叉树结构，
而且是排好序的二叉树来创建。如图8-6-3所示，62、88 、58创建好后，下一个数47因比58小，是它的左子树（见③）， 35
是47的左子树（见④）， 73比62大，但却比88 小，是88 的左子树（见⑤），51比62小、比58 小、比47 大，是47的右子树（见⑥），
99 比62 、88都大，是88的右子树（见⑦），37比62 、58 、47 都小，但却比35大，是35 的右子树（见⑧），
93则因比62 、88大是99的左子树（见⑨）。  
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_6.jpg)  
这样我们就得到了一棵二叉树，并且当我们对它进行中序遍历时，就可以得到一个有序的序列{35，37，47，51，58，62，73，88，93，99}，
所以我们通常称它为二叉排序树。  
二叉排序树( Binary Sort Tree )。又称为二叉查找树。它或者是一楝空树，或者是具有下列性质的二叉树。  
+ 若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；
+ 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
+ 它的左、右子树也分别为二叉排序树。 

从二叉排序树的定义也可以知道，它前提是二叉树，然后它采用了递归的定义方法，再者，它的结点间满足一定的次序关系，
左子树结点一定比其双亲结点小，右子树结点一定比其双亲结点大。  
构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找相插入删除关键字的速度。不管怎么说，在一个有序数据集上的查找，速度总是要快于无序的
数据集的，而二叉排序树这种非线性的结构，也有利于插入和删除的实现。

##### 8.5.1二叉排序树插入、查找、删除操作

{% highlight java %}
import java.util.Random;  
  
/** 
 * 二叉排序树（又称二叉查找树） 
 * （1）可以是一颗空树 
 * （2）若左子树不空，则左子树上所有的结点的值均小于她的根节点的值 
 * （3）若右子树不空，则右子树上所有的结点的值均大于她的根节点的值 
 * （4）左、右子树也分别为二叉排序树 
 *  
 *  
 * 性能分析： 
 * 查找性能： 
 *      含有n个结点的二叉排序树的平均查找长度和树的形态有关， 
 *      （最坏情况）当先后插入的关键字有序时，构成的二叉排序树蜕变为单枝树。查找性能为O(n) 
 *      （最好情况）二叉排序树的形态和折半查找的判定树相同，其平均查找长度和log2(n)成正比 
 *  
 *  
 * 插入、删除性能： 
 *      插入、删除操作间复杂度都O(log(n))级的， 
 *      即经过O(log(n))时间搜索到了需插入删除节点位置和删除节点的位置 
 *      经O(1)级的时间直接插入和删除 
 *      与顺序表相比，比序顺序表插入删除O(n)(查找时间O(log(n))移动节点时间O(n))要快 
 *      与无序顺序表插入时间O(1)，删除时间O(n)相比，因为是有序的，所查找速度要快很多 
 *  
 */  
  
public class BinarySortTree {  
  
    private Node root = null;  
  
      
    /**查找二叉排序树中是否有key值*/  
    public boolean searchBST(int key){  
        Node current = root;  
        while(current != null){  
            if(key == current.getValue())  
                return true;  
            else if(key < current.getValue())  
                current = current.getLeft();  
            else  
                current = current.getRight();  
        }  
        return false;  
    }  
      
      
    /**向二叉排序树中插入结点*/  
    public void insertBST(int key){  
        Node p = root;  
        /**记录查找结点的前一个结点*/  
        Node prev = null;  
        /**一直查找下去，直到到达满足条件的结点位置*/  
        while(p != null){  
            prev = p;  
            if(key < p.getValue())  
                p = p.getLeft();  
            else if(key > p.getValue())  
                p = p.getRight();  
            else  
                return;  
        }  
        /**prve是要安放结点的父节点，根据结点值得大小，放在相应的位置*/  
        if(root == null)  
            root = new Node(key);  
        else if(key < prev.getValue())  
            prev.setLeft(new Node(key));  
        else prev.setRight(new Node(key));  
    }  
      
      
      
    /** 
     * 删除二叉排序树中的结点 
     * 分为三种情况：（删除结点为*p ，其父结点为*f） 
     * （1）要删除的*p结点是叶子结点，只需要修改它的双亲结点的指针为空 
     * （2）若*p只有左子树或者只有右子树，直接让左子树/右子树代替*p 
     * （3）若*p既有左子树，又有右子树 
     *      用p左子树中最大的那个值（即最右端S）代替P，删除s，重接其左子树 
     * */  
    public void deleteBST(int key){  
        deleteBST(root, key);  
    }  
    private boolean deleteBST(Node node, int key) {  
        if(node == null) return false;  
        else{  
            if(key == node.getValue()){  
                return delete(node);  
            }  
            else if(key < node.getValue()){  
                return deleteBST(node.getLeft(), key);  
            }  
            else{  
                return deleteBST(node.getRight(), key);  
            }  
        }  
    }  
  
    private boolean delete(Node node) {  
        Node temp = null;  
        /**右子树空，只需要重接它的左子树 
         * 如果是叶子结点，在这里也把叶子结点删除了 
         * */  
        if(node.getRight() == null){  
            temp = node;  
            node = node.getLeft();  
        }  
        /**左子树空， 重接它的右子树*/  
        else if(node.getLeft() == null){  
            temp = node;  
            node = node.getRight();  
        }  
        /**左右子树均不为空*/  
        else{  
            temp = node;  
            Node s = node;  
            /**转向左子树，然后向右走到“尽头”*/  
            s = s.getLeft();  
            while(s.getRight() != null){  
                temp = s;  
                s = s.getRight();  
            }  
            node.setValue(s.getValue());  
            if(temp != node){  
                temp.setRight(s.getLeft());  
            }  
            else{  
                temp.setLeft(s.getLeft());  
            }  
        }  
        return true;  
    }  
  
      
    /**中序非递归遍历二叉树 
     * 获得有序序列 
     * */  
    public void nrInOrderTraverse(){  
        Stack<Node> stack = new Stack<Node>();  
        Node node = root;  
        while(node != null || !stack.isEmpty()){  
            while(node != null){  
                stack.push(node);  
                node = node.getLeft();  
            }  
            node = stack.pop();  
            System.out.println(node.getValue());  
            node = node.getRight();  
        }  
    }  
      
    public static void main(String[] args){  
        BinarySortTree bst = new BinarySortTree();  
        /**构建的二叉树没有相同元素*/  
        int[] num = {4,7,2,1,10,6,9,3,8,11,2, 0, -2};  
        for(int i = 0; i < num.length; i++){  
            bst.insertBST(num[i]);  
        }  
        bst.nrInOrderTraverse();  
        System.out.println(bst.searchBST(10));  
        bst.deleteBST(2);  
        bst.nrInOrderTraverse();  
    }  
      
      
    /**二叉树的结点定义*/  
    public class Node{  
        private int value;  
        private Node left;  
        private Node right;  
          
        public Node(){  
        }  
        public Node(Node left, Node right, int value){  
            this.left = left;  
            this.right = right;  
            this.value = value;  
        }  
        public Node(int value){  
            this(null, null, value);  
        }  
          
        public Node getLeft(){  
            return this.left;  
        }  
        public void setLeft(Node left){  
            this.left = left;  
        }  
        public Node getRight(){  
            return this.right;  
        }  
        public void setRight(Node right){  
            this.right = right;  
        }  
        public int getValue(){  
            return this.value;  
        }  
        public void setValue(int value){  
            this.value = value;  
        }  
    }  
      
} 
{% endhighlight %}

##### 8.5.2二叉排序树总结

总之，二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素元的优点，只要找到合适的插入和删除位置后，仅需修改链接指针
即可。插入删除的时间性能比较好。而对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。极端情
况， 最少为1次，即根结点就是要找的结点，最坏也不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉排序树的形状。可问题就在于，二叉排序树的形杖
是不确定的。  
例如(62 ， 88，58，47，35，73，51，99，37，93}这样的数组，我们可以构建如图8-6-18左图的二叉排序树。但如果数组元素的次序是从小到大有序，
如(35，37，47，51，58，62，73，88，93，99 )，则二叉排序树就成了极端的右斜树，注意它依然是一棵二叉排序树，如图8-6-18的右图。
此时，同样是查找结点99， 左图只需要两次比较，而右图就需要10次比较才可以得到结果，二者差异很大。  
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_7.jpg)    
也就是说，我们希望二叉排序树是比较平衡的，即其深度与完全二叉树相同，近似于折半查找，事实上，图8-6-18的左图也不够平衡， 明显的左重右轻。  
不平衡的最坏情况就像是图8-6-18右图的斜树，查找时间复杂度为O（n），这等同于顺序查找。  
因此，如果我们希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树。这样我们就引申出另一个问题，如何让二叉排序树平衡的问题。

#### 8.6平衡二叉树( AVL 树)

**平衡二叉树，是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。**  
从平衡二叉树的英文名字，你也可以体会到，它是一种高度平衡的二叉排序树。那什么叫做高度平衡呢？意思是说，要么它是一棵空树，要么它的左子树和右子树都
是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。 我们**将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF (Balance Factor)**，
那么平衡二叉树上所有结点的平衡因子只可能是-1 、0 和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。  
看图8-7-2，为什么图1是平衡二叉树，而图2却不是呢？这里就是考查我们对平衡二叉树的定义的理解，它的前提首先是一棵二叉排序树，右上图的59比58大，
却是58的左子树，这是不符合二叉排序树的定义的。图3不是平衡二叉树的原因就在于，结点58的左子树高度为2，而右子树为空，二者差大于了绝对值1，因此它也
不是平衡的。而经过适当的调整后的图4，它就符合了定义，因此它是平衡二叉树。
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_8.jpg)   
距离插入结点最近的，且平衡因子的绝对值大于1 的结点为根的子树，我们称为最小不平衡子树。图8-7-3，当新插入结点37时，距离它最近的平衡因子绝时值超过
1的结点是58 (即它的左子树高度2减去右子树高度0），所以从58开始以下的子树为最小不平衡子树。
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_9.jpg)   

##### 8.6.1平衡二叉树实现原理

平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持
二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。  
为了能在讲解算法时轻松一些，我们先讲一个平衡二叉树构建过程的例子。假设我们现在有一个数组a[10]={3， 2，1，4，5，6，7，10，9，8}需要构建二叉排序树。
在没有学习平衡二叉树之前，根据二叉排序树的特性，我们通常会将它构建成如图8-7-4的图1所示的样子。虽然它完全符合二叉排序树的定义，
但是对这样高度达到8的二叉树来说，查找是非常不利的。我们更期望能构建成如图8-7-4 的图2的样子，高度为4 的二叉排序树才可以提供高效的查找效率。
那么现在我们就来研究如何将一个数组构建出图2的树结构。  
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_10.jpg)  
对于数组a[10]={3,2,1,4,5,6,7,10,9,8}的前两位3和2，我们很正常地构建，到了第3个数“1”时，发现此时根结点“3”的平衡因子变成了2，此时整棵树都成了最小
不平衡子树，因此需要调整，如图8-7-5的图1(结点左上角数字为平衡因于BF值) 。因为BF值为正，因此我们将整个树进行右旋(顺时针旋转)，此时结点2成了
根结点，3成了2的右孩子，这样三个结点的BF值均为0，非常的平衡，如图8-7-5的图2所示。  
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_11.jpg)    
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_12.jpg)    
然后我们再增加结点4 ，平衡因子没发生改变，如图3。增加结点5时，结点3的BF值为-2，说明要旋转了。由于BF是负值，所以我们对这棵最小平衡子树进行
左旋(逆时针旋转)，如图4，此时我们整个树又达到了平衡。  
继续，增加结点6时，发现根结点2的BF值变成了-2， 如图8-7-6 的图6。 所以我们对根结点进行了左旋，注意此时本来结点3是4的左孩子，由于旋转后需要满
足二叉排序树特性，因此它成了结点2的右孩子，如图7。增加结点7，同样的左旋转，使得整棵树达到平衡，如图8和图9所示。
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_13.jpg)   
当增加结点10时，结构无变化，如图8-7-7的图10。再增加结点9，此时结点7的BF变成了-2，理论上我们只需要旋转最小不平衡子树7 、9 、10 即可，但是如果
左旋转后，结点9就成了10的右孩子，这是不符合二叉排序树的特性的，此时不能简单的左旋，如图11所示。  
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_14jpg)     
仔细观察图11，发现根本原因在于结点7的BF是-2，而结点10的BF是1,也就是说，它们俩一正一负，符号并不统一，而前面的几次旋转，无论左还是右旋，
最小不平衡子树的根结点与它的子结点符号都是相同的。这就是不能直接旋转的关键。那怎么办呢？  
不统一，不统一就把它们先转到符号统一再说，于是我们先对结点9和结点10进行右旋，使得结点10成了9的右子树，结点9的BF为-1，此时就与结点7的
BF值符号统一了，如图8-7-7的图12所示。  
这样我们再以结点7为最小不平衡子树进行左旋，得到图8-7-8的图13。接着插入8，情况与刚才类似，结点6 的BF是-2 ，而它的右孩子9的BF是1， 如图14，
因此首先以9为根结点，进行右旋，得到图15，此时结点6和结点7的符号都是负，再以6为根结点左旋，最终得到最后的平衡二叉树，如图8-7-8的图16 所示。  
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_15jpg)     
所谓的平衡二叉树，其实就是在二叉排序树创建过程中保证它的平衡性，一旦发现有不平衡的情况，马上处理，这样就不会造成不可收拾的情况出现。
通过刚才这个例子，你会发现，当最小不平衡子树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋，如上例中结点1、5、6、7 的插入等。
插入结点后，最小不平衡子树的BF与它的子树的BF符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡
操作，如上例中结点9 、8的插入时。  

##### 8.6.2平衡二叉树实现算法

`略...`

如果我们需要查找的集合本身没有顺序，在频繁查找的同时也需要经常的插入和删除操作，显然我们需要构建一棵二叉排序树，但是不平衡的二叉排序树，
查找效率是非常低的，因此我们需要在构建时，就让这棵二叉排序树是平衡二叉树，此时我们的查找时间复杂度就为O (logn) ，而插入和删除也为O(logn)。
这显然是比较理想的一种动态查找表算法。

#### 8.7多路查找树(B树)

我们前面讨论过的数据结构，处理数据都是在内存中，因此考虑的都是内存中的运算时间复杂度。  
但如若我们要操作的数据集非常大，大到内存已经没办法处理了怎么办呢？如数据库中的上千万条记录的数据表、硬盘中的上万个文件等。在这种情况下，
对数据的处理需要不断从硬盘等存储设备中调入或调出内存页面。  
一旦涉及到这样的外部存储设备，关于时间复杂度的计算就会发生变化，访问该集合元素的时间已经不仅仅是寻找该元素所需比较次数的函数，
我们必须考虑对硬盘等外部存储设备的访问时间以及将会对该设备做出多少次单独访问。  
试想一下，为了要在一个拥有几十万个文件的磁盘中查找一个文本文件，你设计的算法需要读取磁盘上万次还是读取几十次，这是有本质差异的。 
此时，为了降低对外存设备的访问次数，我们就需要新的数据结构来处理这样的问题。  
我们之前谈的树，都是一个结点可以有多个孩子，但是它自身只存储一个元素。二叉树限制更多，结点最多只能有两个孩子。
一个结点只能存储一个元素，在元素非常多的时候，就使得要么树的度非常大(结点拥有子树的个数的最大值)，要么树的高度非常大，甚至两者都必须足够大才
行。这就使得内存存取外存次数非常多，这显然成了时间效率上的瓶颈，这迫使我们要打破每个结点只存储一个元素的限制，为此引入了多路查找树的概念。  
**多路查找树，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。**由于它是查找树，所有元素之间存在某种特定的排序关系。  
在这里，每一个结点可以存储多少个元素，以及它的孩子数的多少是非常关键的。为此，我们讲解它的4 种特殊形式：2-3 树、2-3- 4 树、B 树和B+树。

##### 8.7.1  2-3 树

**2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子(我们称它为2结点)或三个孩子(我们称它为3 结点)。**  
一个2结点包含一个元素和两个孩子(或没有孩子)，且与二叉排序树类似，左子树包含的元素小子该元素，右子树包含的元素大于在该元素。不过，与二叉排序树不同
的是，这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。  
一个3结点包含一小一大两个元素和三个孩子(或没有孩子)，一个3 结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素
的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。  
并且2-3 树中所有的叶子都在同一层次上。如图8-8-2所示，就是一棵有效的2-3树。  
事实上，2-3 树复杂的地方就在于新结点的插入和已有结点的删除。毕竟，每个结点可能是2结点也可能是3结点，要保证所有叶子都在同一层次，是需要进行一番
复杂操作的。  
![](http://7te9au.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E6%9F%A5%E6%89%BE_16jpg)  

`2-3树的插入删除实现：略...`  

##### 8.7.2  2-3-4 树

它其实就是2-3 树的概念扩展，包括了4结点的使用。一个4 结点包含小中大三个元素和四个孩子(或没有孩子)，一个4结点要么没有孩子，
要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包
含大于第二元素，小子最大元素的元素；右子树包含大于最大元素的元素。
由于2-3-4 树和2-3树是类似的，我们这里就不介绍了。

##### 8.7.3  B 树、B+树

**B 树( B-tree ) 是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶(order）**，因此，2-3树是3阶B树，2-3-4树是4
阶B 树。  
[B树及B+参考博客](https://www.cnblogs.com/George1994/p/7008732.html)

#### 8.8 散列表查找(晗希表}概述

`略...`

#### 8.9 散到函数的构造方法

`略...`

#### 8.10 处理散列冲突的方法

`略...`

#### 8.11 散到表查找实现

`略...`


 



 




















